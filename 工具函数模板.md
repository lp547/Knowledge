# STL概论

## 基本概念

STL(Standard Template Library,标准模板库)，是**惠普实验室**开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。
	STL 从广义上分为: **容器(container) 算法(algorithm) 迭代器(iterator)**,容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上

## **STL六大组件简介**

***\*容器：\****各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。

***\*算法：\****各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.

***\*迭代器：\****扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> ,operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。

***\*仿函数：\****行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template

***\*适配器：\****一种用来修饰容器或者仿函数或迭代器接口的东西。

***\*空间配置器：\****负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.

STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。

## 优点

高可重用性，高性能，高移植性，跨平台

高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知
识，已经给大家介绍了。
高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)
高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。

# STL三大组件

## 容器

任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。

常用的数据结构分为***\*序列式容器\****和***\*关联式容器\****两种。

- 序列式容器就是容器元素在容器中的位置是由元素进入容器的时间和地点来决定。Vector容器、Deque容器、List容器、Stack容器、Queue容器。
- 关联式容器是指容器已经有了一定的规则，容器元素在容器中的位置由我的规则来决定。Set/multiset容器 Map/multimap容器 

## 算法

以有限的步骤，解决逻辑或数学上的问题，我们叫做算法(Algorithms).

STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，数据结构是问题的载体，算法与数据结构相辅相成。

算法分为:***\*质变算法\****和***\*非质变算法\****。

质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等

***\*再好的编程技巧，也无法让一个笨拙的算法起死回生。\****

##  迭代器

迭代器(iterator)是一种抽象的设计概念，提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

迭代器的种类:

| 输入迭代器     | 提供对数据的只读访问               | 只读，支持++、==、！=                   |
| -------------- | ---------------------------------- | --------------------------------------- |
| 输出迭代器     | 提供对数据的只写访问               | 只写，支持++                            |
| 前向迭代器     | 提供读写操作，并能向前推进迭代器   | 读写，支持++、==、！=                   |
| 双向迭代器     | 提供读写操作，并能向前和向后操作   | 读写，支持++、--，                      |
| 随机访问迭代器 | 提供读写操作，并能在数据中随机移动 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

## 案例

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
#include<algorithm>
usingnamespace std;

//STL 中的容器 算法 迭代器
void test01(){
	vector<int> v;//STL 中的标准容器之一 ：动态数组
	v.push_back(1);//vector 容器提供的插入数据的方法
	v.push_back(5);
	v.push_back(3);
	v.push_back(7);
	//迭代器
	vector<int>::iterator pStart = v.begin();//vector 容器提供了 begin()方法 返回指向第一个元素的迭代器
	vector<int>::iterator pEnd = v.end();//vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器
	//通过迭代器遍历
	while(pStart != pEnd){
			cout <<*pStart <<" ";
		pStart++;
	}
	cout << endl;
	//算法 count 算法 用于统计元素的个数
	int n = count(pStart, pEnd,5);
	cout <<"n:"<< n << endl;
}
//STL 容器不单单可以存储基础数据类型，也可以存储类对象
class Teacher
{
public:
	Teacher(int age):age(age){};
	~Teacher(){};
public:
	int age;
};
void test02(){
	vector<Teacher> v;//存储 Teacher 类型数据的容器
	Teacher t1(10), t2(20), t3(30);
	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);
	vector<Teacher>::iterator pStart = v.begin();
	vector<Teacher>::iterator pEnd = v.end();
	//通过迭代器遍历
	while(pStart != pEnd){
		cout << pStart->age <<" ";
		pStart++;
	}
	cout << endl;
}
//存储 Teacher 类型指针
void test03(){
	vector<Teacher*> v;//存储 Teacher 类型指针
	Teacher* t1 =new Teacher(10);
	Teacher* t2 =new Teacher(20);
	Teacher* t3 =new Teacher(30);
	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);
	//拿到容器迭代器
	vector<Teacher*>::iterator pStart = v.begin();
	vector<Teacher*>::iterator pEnd = v.end();
		//通过迭代器遍历
	while(pStart != pEnd){
		cout <<(*pStart)->age <<" ";
		pStart++;
	}
	cout << endl;
}
//容器嵌套容器 难点(不理解，可以跳过)
void test04(){
	vector<vector<int>> v;//容器中存储容器
	vector<int> v1, v2, v3;
	v1.push_back(1);
	v1.push_back(2);
	v2.push_back(10);
	v3.push_back(100);
	v3.push_back(200);
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);
	//拿到容器迭代器
	vector<vector<int>>::iterator pStart = v.begin();
	vector<vector<int>>::iterator pEnd = v.end();
	//通过迭代器遍历
	while(pStart != pEnd){
		vector<int> vTemp =*pStart;//获得迭代器当前指向的容器
		vector<int>::iterator tmpStart = vTemp.begin();
		vector<int>::iterator tmpEnd = vTemp.end();
		for(; tmpStart != tmpEnd; tmpStart++){
			cout <<*tmpStart <<" ";
		}
		cout << endl;
		pStart++;
	}
}
int main(){
	//test01();
	//test02();
	//test03();
	test04();
	system("pause");
	return EXIT_SUCCESS;
}
```

# string

## string容器

### string容器基本概念

C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。

String和c风格字符串对比：

- Char*是一个指针，String是一个类

string封装了char*，管理这个字符串，是一个char*型的容器。

- String封装了很多实用的成员方法

查找find，拷贝copy，删除delete 替换replace，插入insert

- 不用考虑内存释放和越界

 string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。

### string容器常用操作

#### string 构造函数

```c++
string();//创建一个空的字符串 例如: string str;      
string(conststring& str);//使用一个string对象初始化另一个string对象
string(constchar* s);//使用字符串s初始化
string(int n, char c);//使用n个字符c初始化 
```

####  string基本赋值操作

```c++
string&operator=(const char* s);//char*类型字符串 赋值给当前的字符串
string&operator=(const string&s);//把字符串s赋给当前的字符串
string&operator=(char c);//字符赋值给当前的字符串string& 
assign(const char *s);//把字符串s赋给当前的字符串string& 
assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
string& assign(const string&s);//把字符串s赋给当前字符串string& 
assign(int n, char c);//用n个字符c赋给当前字符串string& 
assign(const string&s, int start, int n);//将s从start开始n个字符赋值给字符串,如s=hello,那么n=3,start=1，那么是hel中从e开始赋值3-1个字符
```

#### string存取字符操作

```c++
char&operator[](int n);//通过[]方式取字符
char& at(int n);//通过at方法获取字符
```

#### string拼接操作

```c++
string& operator+=(const string& str);//重载+=操作符
string& operator+=(const char* str);//重载+=操作符
string& operator+=(const char c);//重载+=操作符string& 
append(const char *s);//把字符串s连接到当前字符串结尾string& 
append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾
string& append(const string&s);//同operator+=()string& 
append(const string&s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾
string& append(int n, char c);//在当前字符串结尾添加n个字符c
```

#### string查找和替换

```c
int find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置
int rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置
string& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str
string& replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s
```

#### string比较操作

```c++
/*
compare函数在>时返回 1，
<时返回 -1，
==时返回 0。
比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。*/
int compare(const string&s) const;//与字符串s比较int 
compare(const char *s) const;//与字符串s比较
```

####  string子串

```c++
string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串
```

####  string插入和删除操作

```c++
string& insert(int pos, const char* s); //插入字符串
string& insert(int pos, const string& str); //插入字符串
string& insert(int pos, int n, char c);//在指定位置插入n个字符
cstring& erase(int pos, int n = npos);//删除从Pos开始的n个字符 
```

####  string和c-style字符串转换

```c++
//string 转 char*
string str = "itcast";
const char* cstr = str.c_str();
//char* 转 string 
char* s = "itcast";
string sstr(s);
```

  为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误.

```c++
	string s ="abcdefg";
	char& a = s[2];
	char& b = s[3];

	a ='1';
	b ='2';

	cout << s << endl;
	cout <<(int*)s.c_str()<< endl;

	s ="pppppppppppppppppppppppp";

	//a = '1';
	//b = '2';//无法修改

	cout << s << endl;
	cout <<(int*)s.c_str()<< endl;
```

输出：

```objective-c
ab12efg
0xae1538
pppppppppppppppppppppppp
0xae1a38

--------------------------------
Process exited after 0.4209 seconds with return value 0
请按任意键继续. . .
```

# pair

## 介绍

pair只含有两个元素（只有两个元素的结构体）

应用：

- 代替二元结构体
- 作为map键值对进行插入（代码如下）

```cpp
map<string, int> mp;
mp.insert(pair<string, int>("lp",1));
// mp.insert(make_pair("lp", 1));
// mp.insert({"lp", 1});
```

初始化操作和赋值操作

```cpp
//头文件
#include <utility>

//1.初始化定义
pair<string, int> p("lp",1);//带初始值的
pair<string, int> p;//不带初始值的

//2.赋值
p = {"wang", 18};
p = make_pair("wang", 18);
p = pair<string, int>("wang", 18);
```

## 访问

```cpp
//定义结构体数组
pair<int,int> p[20];
for(int i = 0; i < 20; i++) {
	//和结构体类似，first代表第一个元素，second代表第二个元素
	cout << p[i].first << " " << p[i].second;
}
```

# tuple

## 介绍

`tuple` 模板是 `pair` 的泛化，可以封装不同类型任意数量的对象。

可以将 `tuple` 理解为 `pair` 的扩展，`tuple` 可以声明二元组，也可以声明三元组。

`tuple` 可以等价于结构体使用。

### 头文件

```cpp
#include <tuple>
```

### 基础用法

#### 声明及初始化

声明一个空的三元组 `tuple`：

```cpp
tuple<int, int, string> t1;
```

赋值：

```cpp
t1 = make_tuple(1, 1, "hahaha");
```

创建的同时初始化：

```cpp
tuple<int, int, int, int> t2(1, 2, 3, 4);
```

可以使用 `pair` 对象构造 `tuple` 对象，但 `tuple` 对象必须是两个元素：

```cpp
auto p = make_pair("wang", 1);
tuple<string, int> t3 {p}; // 将 pair 对象赋给 tuple 对象
```

```cpp
#include <iostream>
#include <tuple>
#include <utility>

int main() {
    std::pair<std::string, int> p("example", 42);
    std::tuple<std::string, int> t3;

    // 使用 std::tie 将 pair 对象的元素分解并赋给 tuple 对象
    std::tie(std::get<0>(t3), std::get<1>(t3)) = p;

    // 打印 tuple 对象的内容
    std::cout << "Tuple elements: " << std::get<0>(t3) << ", " << std::get<1>(t3) << std::endl;

    return 0;
}
```



#### 元素操作

获取 `tuple` 对象 `t` 的第一个元素：

```cpp
int first = get<0>(t);
```

修改 `tuple` 对象 `t` 的第一个元素：

```cpp
get<0>(t) = 1;
```

### 函数操作

#### 获取元素个数

```cpp
tuple<int, int, int> t(1, 2, 3);
cout << tuple_size<decltype(t)>::value << "\n"; // 3
```

#### 获取对应元素的值

通过 `get<n>(obj)` 方法获取，`n` 必须为数字不能是变量：

```cpp
tuple<int, int, int> t(1, 2, 3);
cout << get<0>(t) << '\n'; // 1
cout << get<1>(t) << '\n'; // 2
cout << get<2>(t) << '\n'; // 3
```

#### 通过 `tie` 解包获取元素值

`tie` 可以让 `tuple` 变量中的值依次赋到 `tie` 中的变量中：

```cpp
int one, three;
string two; 
tuple<int, string, int> t(1, "hahaha", 3);
tie(one, two, three) = t;
cout << one << two << three << "\n"; // 1hahaha3
```
# array

## 介绍
`array`是C++11新增的容器，**效率与普通数组相差无几**，比**`vector`效率要高**大小固定，无法动态的扩展或收缩

**注意：** `array`的使用要在`std`命名空间里

## 简单使用
### 1. 声明与初始化
1.1. 基础数据类型

```cpp
std::array<int, 100> a;//大小为100的`int`型数组，元素的值不确定
std::array<int, 100> b{};//大小为100的`int`型数组，初始值均为0
std::array<int, 100> c{1, 2, 3};//声明一个大小为100的`int`型数组，初始化部分值，其余全部为0
std::array<int, 100> d = {1, 2, 3};//或者
```

1.2. 高级数据类型

- 不同于数组的是对元素类型不做要求，可以套**结构体**

```cpp
std::array<std::string, 2> s = {"ha", std::string("haha")};
std::array<node, 2> e;
```

2. 取存元素值

修改元素

```cpp
std::array<int, 4> arr = {1, 2, 3, 4};
arr[0] = 4;
```

#### 访问元素
- 下标访问

```cpp
for (int i = 0; i < 4; ++i) {
    std::cout << arr[i] << " ";
}
```

- 利用`auto`访问

```cpp
for (auto i : arr) {
    std::cout << i << " ";
}
```

- 迭代器访问

```cpp
auto it = arr.begin();
for (; it != arr.end(); ++it) {
    std::cout << *it << " ";
}
```

- `at()`函数访问

```cpp
int res = arr.at(1) + arr.at(2);
std::cout << res << std::endl;
```

- `get`方法访问

```cpp
std::get<1>(arr) = x;
```

### 3. 成员函数
| 成员函数              | 功能                                                         |
| --------------------- | ------------------------------------------------------------ |
| `begin()`             | 返回容器中第一个元素的访问迭代器（地址）                     |
| `end()`               | 返回容器最后一个元素之后一个位置的访问迭代器（地址）         |
| `rbegin()`            | 返回最后一个元素的访问迭代器（地址）                         |
| `rend()`              | 返回第一个元素之前一个位置的访问迭代器（地址）               |
| `size()`              | 返回容器中元素的数量，其值等于初始化 `array` 类的第二个模板参数N |
| `max_size()`          | 返回容器可容纳元素的最大数量，其值始终等于初始化 `array` 类的第二个模板参数N |
| `empty()`             | 判断容器是否为空                                             |
| `at(n)`               | 返回容器中n位置处元素的引用，函数会自动检查n是否在有效的范围内，如果不是则抛出 `out_of_range` 异常 |
| `front()`             | 返回容器中第一个元素的直接引用，函数不适用于空的 `array` 容器 |
| `back()`              | 返回容器中最后一个元素的直接引用，函数不适用于空的 `array` 容器 |
| `data()`              | 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能 |
| `fill(x)`             | 将x这个值赋值给容器中的每个元素，相当于初始化                |
| `array1.swap(array2)` | 交换 `array1` 和 `array2` 容器中的所有元素，但前提是它们具有相同的长度和类型 |

### 4. 部分用法示例
- data()
    - 指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。

- `at()`
  
    - 下标为1的元素加上下标为2的元素，答案为5
    
    ```cpp
    int result = arr.at(1) + arr.at(2);
    std::cout << result << std::endl;
    ```
    
- `fill()`
  
    - `array`的`fill()`函数，将`arr`数组全部元素值变为`x`
    
    ```cpp
    arr.fill(x);
    ```
    
- 另外还有其它的`fill()`函数:将`arr`数组[begin, end)全部值变为`x`

    ```cpp
    fill(arr.begin(), arr.end(), x);
    ```

- `get`方法获取元素值
  
    - 将`arr`数组下标为1位置处的值改为`x`
    - 注意获取的下标只能写数字，不能填变量
    
    ```cpp
    std::get<1>(arr) = x;
    ```
    
- 排序

```cpp
sort(arr.begin(), arr.end());
```


# vector

## 介绍 ：

`vector`为可变长数组（动态数组），定义的`vector`数组可以随时**添加数值**和**删除元素**。

**注意**：数组在栈中

```cpp
void exampleFunction() {
    // 在栈上声明数组
    int stackArray[100000];  // 可能导致栈溢出，取决于栈的大小
}
```

vector在堆中

```cpp
void exampleFunction() {
    // 在堆上动态分配 vector
    std::vector<int> heapVector(100000);  // 安全，不会导致栈溢出
}
```

![image-20240415163143129](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240415163143129.png)

##  **vector迭代器**

Vector维护一个线性空间，**普通指针**都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator->, operator++, operator--, operator+, operator-, operator+=, operator-=, 普通指针天生具备。Vector支持**随机存取**，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators).

根据上述描述，如果我们写如下的代码：

```c++
TeacherVector<int>::iterator it1;//Int

Vector<Teacher>::iterator it2;//Teacher
```

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
usingnamespace std;

int main(){

	vector<int> v;
	for(int i =0; i <10;i ++){
		v.push_back(i);
		cout << v.capacity()<< endl;
	}

	int* start =&v[0];
	int* end =&v[v.size()-1];

	for(; start <= end; start++){
		cout <<*start << endl;
	}

	system("pause");
	return EXIT_SUCCESS;
}
```

## 头文件：

```c++
#include <vector>
```

## 初始化：

- 一维初始化：

  ```cpp
  vector<int> a; //定义了一个名为a的一维数组,数组存储int类型数据
  vector<double> b;//定义了一个名为b的一维数组，数组存储double类型数据
  vector<node> c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型
  ```
  
  指定长度和初始值的初始化
  
  ```c++
  vector<int> v(n);// 长度为n的数组，初始值默认为0，下标范围[0, n - 1]
  vector<int> v(n, 1);// v[0] 到 v[n - 1]所有的元素初始值均为1
  //注意:指定长度后的vector就相当于正常的数组了
  ```

  初始化中有多个元素

```cpp
vector<int> a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5
```

  拷贝初始化

```cpp
vector<int> a(n + 1, 0);
vector<int> b(a); // 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组
vector<int> c = a; // 也是拷贝初始化,c和a是完全一样的数组
```

二维初始化
定义第一维固定长度为5，第二维可变化的二维数组

```cpp
vector<int> v[5];//定义可变长二维数组
//注意:行不可变(只有5行,而列可变,可以在指定行添加元素
//第一维固定长度为5，第二维长度可以改变
```

每个数组元素均为空，第二维可变长。可以进行下述操作：

```cpp
v[1].push_back(2);
v[2].push_back(3);
```

行列均可变

```cpp
//初始化二维均可变长数组
vector<vector<int>> v;//定义一个行和列均可变的二维数组
```

应用：可以在v数组里面装多个数组

```cpp
vector<int> t1{1, 2, 3, 4};
vector<int> t2{2, 3, 4, 5};
v.push_back(t1);
v.push_back(t2);
v.push_back({3, 4, 5, 6});// {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector行列长度均固定 n + 1行 m + 1列初始值为0
```

行列长度均固定 **n + 1**行 **m + 1**列初始值为0

```cpp
vector<vector<int>> a(n + 1, vector<int>(m + 1, 0));
```

c++17或者c++20支持的形式（不常用），与上面相同的初始化

```cpp
vector a(n + 1, vector(m + 1, 0));方法函数：
```

## 方法函数：

**c指定为数组名称**，含义中注明**算法复杂度**。

| 代码                       | 含义                                                  |
| -------------------------- | ----------------------------------------------------- |
| c.front()                  | 返回第一个数据O ( 1 )                                 |
| c.back()                   | 返回数组中的最后一个数据 O(1)                         |
| c.pop_back()               | 删除最后一个数据O ( 1 )                               |
| c.push_back(element)       | 在尾部加一个数据O ( 1 )                               |
| c.size()                   | 返回实际数据个数（unsigned类型）O ( 1 )               |
| c.clear()                  | 清除元素个数O ( N ) ，N为元素个数                     |
| c.resize(n, v)             | 改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0 |
| c.insert(it, x)            | 向任意迭代器it插入一个元素x ，O (N)                   |
| c.insert(c.begin() + 2,-1) | 将-1插入c[2]的位置                                    |
| c.erase(first,last)        | 删除[first,last)的所有元素，O ( N )                   |
| c.begin()                  | 返回首元素的迭代器（通俗来说就是地址O(1)              |
| c.end()                    | 返回最后一个元素后一个位置的迭代器（地址)O(1)         |
| c.empty()                  | 判断是否为空，为空返回真，反之返回假O(1)              |

注意：

- **end()**返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此

- 使用 **vi.resize(n, v)** 函数时，若 vi 之前指定过大小为 pre

  - **pre > n** ：即数组大小变小了，数组会保存前 n 个元素，前 n 个元素值为原来的值，不是都为 v

  - **pre < n** ：即数组大小变大了，数组会在后面插入 n - pre 个值为 v 的元素

也就是说，这个初始值 **v** 只对**新插入的元素生效**。

```cpp
#include <vector>
using namespace std;
void out(vector<int> &a) { 
    for (auto &x: a) cout << x << " "; 
    cout << "\n"; 
}
int main() {
	vector<int> a(5, 1);
	out(a); // 1 1 1 1 1
	a.resize(10, 2);
	out(a); // 1 1 1 1 1 2 2 2 2 2
	a.resize(3, 3);
	out(a); // 1 1 1
	return 0;
}
```

## 排序：

> 使用`sort`排序要： 
>
> ```cpp
> sort(c.begin(), c.end());
> ```

## 访问：

下标法 ： 和普通数组一样
注意：一维数组的下标是从 0 到 v.size()-1 

```cpp
//添加元素
for(int i = 0; i < 5; i++)
	vi.push_back(i);
//下标访问 
for(int i = 0; i < 5; i++)
	cout << vi[i] << " ";
```

迭代器法 ： 类似指针访问 

```cpp
#include <iostream>
#include <vector>
int main() {
    // 创建一个 std::vector
    std::vector<int> myVector = {1, 2, 3, 4, 5};
    for (std::vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it)
    std::cout << *it << " ";//*it获取当前位置的值
    auto it = vi.begin();
	while (it != vi.end()) {
    	cout << *it << "\n";
    	it++;}
    return 0;
}
```

使用auto ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）

```cpp
#include <iostream>
#include <vector>
int main() {
    std::vector<int> myVector = {1, 2, 3, 4, 5};
    for (auto element : myVector)
        std::cout << element << " ";
    return 0;
}
```

##  **vector的数据结构**

Vector所采用线性连续空间

一个vector的容量永远大于或等于其大小，一旦容量等于大小，下次再有新增元素，整个vector容器就得另觅居所。

***\*注意：\****

  所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效

### **3.2.4 vector常用API操作**

#### vector构造函数

```c++
vector<T> v; //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);//构造函数将n个elem拷贝给本身。
vector(const vector &vec);//拷贝构造函数。
//例子 使用第二个构造函数 我们可以...
int arr[] = {2,3,4,1,9};
vector<int> v1(arr, arr + sizeof(arr) / sizeof(int)); 
```

#### vector常用赋值操作

```c++
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector& operator=(const vector  &vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。
```

#### vector大小操作

```c++
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
```

#### vector数据存取操作

```c++
at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素
```

#### vector插入和删除操作

```c++
insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素
```

### vector小案例

#### 巧用swap，收缩内存空间

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
using namespace std;

int main(){

	vector<int> v;
	for(int i =0; i <100000;i ++){
		v.push_back(i);
	}

	cout <<"capacity:"<< v.capacity()<< endl;
	cout <<"size:"<< v.size()<< endl;

	//此时 通过resize改变容器大小
	v.resize(10);

	cout <<"capacity:"<< v.capacity()<< endl;
	cout <<"size:"<< v.size()<< endl;

	//容量没有改变
	vector<int>(v).swap(v);

	cout <<"capacity:"<< v.capacity()<< endl;
	cout <<"size:"<< v.size()<< endl;


	system("pause");
	return 0;
}
```

```objective-c
capacity:131072
size:100000
capacity:131072
size:10
capacity:10
size:10
请按任意键继续. . .
```



#### reserve预留空间

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
usingnamespace std;

int main(){

	vector<int> v;

	//预先开辟空间
	v.reserve(100000);

	int* pStart =NULL;
	int count =0;
	for(int i =0; i <100000;i ++){
		v.push_back(i);
		if(pStart !=&v[0]){
			pStart =&v[0];
			count++;
		}//每次添加元素后，检查向量的起始地址是否发生了变化。如果发生了变化，将 pStart 更新为新的起始地址，并增加 count 的值
	}
	cout <<"count:"<< count << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```

```objective-c
count: 0
请按任意键继续. . .
```

# list

##  list容器基本概念

链表是一种物理**存储单元**上**非连续、非顺序的存储结构**，数据元素的逻辑顺序是通过链表中的[指针](http://baike.baidu.com/view/159417.htm)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](http://baike.baidu.com/view/38785.htm)的数据域，另一个是存储下一个结点地址的[指针](http://baike.baidu.com/view/159417.htm)域。

`std::list` 是C++标准模板库（STL）中的双向链表容器

![image-20240417194406571](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240417194406571.png)

- n 采用动态存储分配，不会造成内存浪费和溢出
- n 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素
- n 链表灵活，但是空间和时间额外耗费较大

##  **list容器的迭代器**

List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。即递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。

由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.

***List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。\***List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响

## 包含头文件

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<list>
usingnamespace std;

int main(){

	list<int> myList;
	for(int i =0; i <10; i ++){
		myList.push_back(i);
	}

	list<int>::_Nodeptr node =  myList._Myhead->_Next;

	for(int i =0; i < myList._Mysize *2;i++){
		cout <<"Node:"<< node->_Myval << endl;
		node = node->_Next;
		if(node == myList._Myhead){
			node = node->_Next;
		}
	}

	system("pause");
	return 0;
}
```

## 创建列表

```cpp
list<T> lstT;//list采用采用模板类实现,对象的默认构造形式：
list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);//构造函数将n个elem拷贝给本身。
list(const list &lst);//拷贝构造函数。
```

## **list数据元素插入和删除操作**

```c++
push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。
```

## list大小操作

```c++
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
```

## list赋值操作

```c++
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list& operator=(const list &lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换。
```

## list数据的存取

```c++
front();//返回第一个元素。
back();//返回最后一个元素。
```



## list反转排序

```c++
reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); //list排序
```

## 迭代器

```cpp
// 使用迭代器遍历列表
for (std::list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {
    // 使用 *it 访问迭代器指向的元素
}
// C++11 中可以使用范围-based for 循环
for (int element : myList) {
    // 使用 element 访问列表中的每个元素
}
```

## 其他操作

- `size()`: 返回列表中元素的数量。
- `empty()`: 如果列表为空则返回 true，否则返回 false。
- `clear()`: 清空列表中的所有元素。

## 注意事项

- `std::list` 支持快速的插入和删除操作，但是随机访问效率较低。

- 考虑对大量元素使用时的额外开销。

  以下是一些`std::list`的高级用法示例：

  ## 1. 自定义类型的列表

  ```cpp
  #include <list>
  #include <string>
  
  struct Person {
      std::string name;
      int age;
  };
  
  int main() {
      std::list<Person> people;
      
      // 添加人员到列表
      people.push_back({"Alice", 30});
      people.push_back({"Bob", 25});
      
      // 遍历列表
      for (const auto& person : people) {
          std::cout << "Name: " << person.name << ", Age: " << person.age << std::endl;
      }
      
      return 0;
  }
  ```

  ### 2. 使用自定义比较函数进行排序

  ```cpp
  #include <list>
  #include <string>
  #include <algorithm>
  
  struct Person {
      std::string name;
      int age;
  };
  
  bool compareByAge(const Person& a, const Person& b) {
      return a.age < b.age;//升序
  }
  
  int main() {
      std::list<Person> people = {{"Alice", 30}, {"Bob", 25}, {"Charlie", 35}};
      
      // 根据年龄排序
      people.sort(compareByAge);
      
      // 打印排序后的列表
      for (const auto& person : people) {
          std::cout << "Name: " << person.name << ", Age: " << person.age << std::endl;
      }
      
      return 0;
  }
  ```

  ### 3. 使用自定义分配器

  ```cpp
  #include <list>
  #include <memory>
  
  // 自定义分配器
  template<typename T>
  struct MyAllocator {
      using value_type = T;
      
      MyAllocator() noexcept = default;
      
      template<typename U>
      MyAllocator(const MyAllocator<U>&) noexcept {}
      
      T* allocate(std::size_t n) {
          return static_cast<T*>(::operator new(n * sizeof(T)));
      }
      
      void deallocate(T* p, std::size_t) noexcept {
          ::operator delete(p);
      }
  };
  
  int main() {
      // 使用自定义分配器的列表
      std::list<int, MyAllocator<int>> myList;
      
      // 添加元素到列表
      myList.push_back(10);
      myList.push_back(20);
      
      // 遍历列表
      for (const auto& value : myList) {
          std::cout << value << std::endl;
      }
      
      return 0;
  }
  ```

# forward_list

是C++标准模板库（STL）中的单向链表容器，与 `std::list` 不同，`std::forward_list` 只能通过一个指针在链表中的一个方向进行遍历。由于它只能单向遍历，因此相对于 `std::list`，`std::forward_list` 的内存开销和迭代器的复杂性更低，但它提供的功能也更少。

下面是 `std::forward_list` 的基本使用说明：

## 包含头文件

```cpp
#include <forward_list>
```

## 创建单向链表

```cpp
std::forward_list<int> myForwardList; // 创建一个空的整数单向链表
```

## 插入元素

```cpp
myForwardList.push_front(10); // 在链表头部插入元素
```

## 删除元素

```cpp
myForwardList.pop_front(); // 删除链表头部的元素
```

## 遍历链表

```cpp
// 使用迭代器遍历链表
for (auto it = myForwardList.begin(); it != myForwardList.end(); ++it) {
    // 使用 *it 访问迭代器指向的元素
}

// C++11 中可以使用范围-based for 循环
for (int element : myForwardList) {
    // 使用 element 访问链表中的每个元素
}
```

## 其他操作

- `empty()`: 如果链表为空则返回 true，否则返回 false。
- `clear()`: 清空链表中的所有元素。

## 注意事项

- `std::forward_list` 只能通过单个指针在链表中的一个方向进行遍历。
- `std::forward_list` 不支持 `push_back()` 和 `pop_back()` 操作，因为它没有直接访问链表末尾的功能。
- 由于 `std::forward_list` 只能在头部插入元素，如果需要在其他位置插入或删除元素，你可能需要使用 `std::list` 或者其他数据结构。
- `std::forward_list` 的迭代器只能往前移动，因此无法回头访问之前的元素。如果需要回头遍历链表，你可能需要使用双向链表（`std::list`）或者其他数据结构。

## 使用场景

- 当需要低内存消耗和高性能的情况下，`std::forward_list` 是一个不错的选择。
- 如果需要在任意位置插入或删除元素，或者需要双向遍历链表，那么 `std::list` 可能更适合。

## 示例代码

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> myList = {1, 2, 3, 4, 5};
    
    // 在头部插入元素
    myList.push_front(0);

    // 删除头部元素
    myList.pop_front();

    // 遍历列表
    for (int element : myList) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

# stack

## 介绍

> 栈是STL中实现的一个先进后出的数据结构。Stack不提供遍历功能，也不提供迭代器
>
> ![image-20240417193120808](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240417193120808.png)

## 声明

```c++
#include<stack>//声明
stack<T> stkT;//stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &stk);//拷贝构造函数
```

## 方法函数

| 代码        | 含义                          | 返回值 |
| ----------- | ----------------------------- | ------ |
| s.push(ele) | 元素ele入栈，增加元素 O ( 1 ) | 空     |
| s.pop()     | 移除栈顶元素 O(1)             | 空     |
| s.top()     | 取得栈顶元素（但不删除）O(1)  | 栈顶值 |
| s.empty()   | 检测栈内是否为空，空为真O(1)  | bool   |
| s.size()    | 返回栈内元素的个数O(1)        | int    |

#### stack赋值操作

```c++
stack& operator=(const stack &stk);//重载等号操作符
```

## 遍历

### 栈遍历

栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中

```cpp
#include <iostream>
#include <stack>
int main() {
    std::stack<int> st;
    
    for (int i = 0; i < 10; ++i) 
    {
        st.push(i);// 将0到9依次压入栈
    }

    while (!st.empty()) {// 遍历栈，直到栈为空
        int tp = st.top();// 获取栈顶元素
        std::cout << tp << " ";  // 输出栈顶元素
        st.pop();}// 弹出栈顶元素
    
    return 0;
}
```

### 数组模拟栈遍历

通过一个**数组**对栈进行模拟，一个存放下标的变量`top`模拟指向栈顶的指针。

**特点：** 比`STL`的`stack`速度更快，遍历元素方便

```cpp
#include <iostream>
const int MAX_SIZE = 10;  // 栈的最大大小
class Stack {
private:
    int arr[MAX_SIZE];  // 用数组实现栈
    int top;            // 栈顶指针
public:
    Stack() : top(-1) {}  // 栈的构造函数，初始时栈顶指针为 -1
    void push(int element) {
        if (top < MAX_SIZE - 1) {
            arr[++top] = element;  // 元素入栈
        } else {std::cout << "栈溢出" << std::endl;}
    }
    void pop() {
        if (top >= 0) {
            --top;  // 弹出栈顶元素
       } else {std::cout << "栈下溢出" << std::endl;}
    }
    int getTop() const {
     if (top >= 0) {return arr[top];  // 返回栈顶元素
        } else {std::cout << "栈空" << std::endl;
            return -1;  // 返回一个标记值表示栈为空
        }
    }
    bool isEmpty() const {
        return top == -1;  // 栈为空的判断条件
    }
};
int main() {
    Stack myStack;

    for (int i = 0; i < 5; ++i) {
        myStack.push(i * 2);  // 入栈
    }
    while (!myStack.isEmpty()) {//遍历
        int topElement = myStack.getTop();
        std::cout << topElement << " ";
        myStack.pop();  // 弹出栈顶元素
    }
    return 0;
}
```

# deque(双端队列)

## 简介

**首尾**都可插入和删除的队列为**双端队列**，deque则是一种**双向开口**的连续线性空间。

![image-20240415170220260](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240415170220260.png)

一在于deque允许使用**常数项时间**对头端进行元素的插入和删除操作。

二在于deque**没有容量**的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来

虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，***其复杂度和vector不是一个量级***，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.

```c++
#include <iostream>
#include <deque>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    deque<int> myDeque = {9, 3, 6, 1, 8, 2, 5, 7, 4}; // 假设有一个deque

    // 将deque复制到vector中
    vector<int> myVector(myDeque.begin(), myDeque.end());

    // 使用STL中的排序算法对vector进行排序
    sort(myVector.begin(), myVector.end());

    // 将排序后的vector复制回deque中
    myDeque.assign(myVector.begin(), myVector.end());

    // 输出排序后的deque
    cout << "Sorted deque: ";
    for (const auto& elem : myDeque) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

```cpp
#include<deque>//添加头文件
deque<int> dq;//初始化定义
```

## deque容器实现原理

vector(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤

Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构

deque是分段连续内存空间，中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多

Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体

![image-20240415172246772](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240415172246772.png)

## **deque常用API**

| 函数                                | 含义                                  |
| ----------------------------------- | ------------------------------------- |
| push_back(x)/push_front(x)          | 把x插入队尾后 / 队首O(1)              |
| back()/front()                      | 返回队尾 / 队首元素O(1)               |
| pop_back() / pop_front()            | 删除队尾 / 队首元素O(1)               |
| erase(iterator it)                  | 删除双端队列中的某一个元素            |
| erase(iterator first,iterator last) | 删除双端队列中[first,last)中的元素    |
| q.empty()                           | 判断是否为空，队列为空，返回true O(1) |
| size()                              | 返回deque的元素数量                   |
| clear()                             | 清空deque                             |

## 排序

deque可以进行排序

```cpp
//从小到大
sort(q.begin(), q.end())
//从大到小排序
sort(q.begin(), q.end(), greater<int>());//deque里面的类型需要是int型
sort(q.begin(), q.end(), greater());//高版本C++才可以用
```

## deque构造函数

```c++
deque<T> deqT;//默认构造形式
deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);//构造函数将n个elem拷贝给本身。
deque(const deque &deq);//拷贝构造函数。 
```

##  deque赋值操作

```c++
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
deque& operator=(const deque &deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换
```



## deque大小操作

```c++
deque.size();//返回容器中元素的个数
deque.empty();//判断容器是否为空
deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值（0）填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
```

 

## **deque双端插入和删除操作**

```c++
push_back(elem);//在容器尾部添加一个数据
push_front(elem);//在容器头部插入一个数据
pop_back();//删除容器最后一个数据
pop_front();//删除容器第一个数据
```

##  deque双端插入和删除操作

```c++
at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();//返回第一个数据。
back();//返回最后一个数据
```

##  deque插入操作

```c++
insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
```

#### **3.3.3.7 deque删除操作**

```c++
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
```

# queue

## 介绍

> 队列是一种***先进先出***的数据结构。Queue不提供遍历功能，也不提供迭代器
>
> ![image-20240417193347569](C:\Users\12964\AppData\Roaming\Typora\typora-user-images\image-20240417193347569.png)

```cpp
//头文件
#include<queue>
//定义初始化
queue<int> q;
std::queue<std::string> strQueue;//字符串
queue<T> queT;//queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &que);//拷贝构造函数
```

## 方法函数

| 函数            | 含义                                            | 返回值         |
| --------------- | ----------------------------------------------- | -------------- |
| q.front()       | 返回队首元素O(1)                                | 返回队首类型值 |
| q.back()        | 返回队尾元素O(1)                                | 返回队尾类型值 |
| q.push(element) | 尾部添加一个element 进队O(1)                    | void           |
| q.pop()         | 删除第一个元素 出队 O(1)                        | void           |
| q.size()        | 返回队列中元素个数，返回值类型unsigned int O(1) | unsigned int   |
| q.empty()       | 判断是否为空，队列为空，返回true O(1)           | bool           |

#### queue赋值操作

```c++
queue& operator=(const queue &que);//重载等号操作符
```

## 遍历

### 队列遍历

```cpp
#include <iostream>
#include <queue>
int main() {
    std::queue<int> myQueue;
    myQueue.push(1); // 向队列中添加一些元素
    myQueue.push(2);
    myQueue.push(3);
    myQueue.push(4);
    while (!myQueue.empty()) { // 向队列中添加一些元素
std::cout << myQueue.front() << " ";  // 输出队首元素
        myQueue.pop(); } // 弹出队首
    return 0;
}
```

### 模拟遍历

```cpp
#include <iostream>
const int MAX_SIZE = 100;  // 队列的最大大小
class Queue {
private:
    int arr[MAX_SIZE];  // 用数组实现队列
    int front;           // 队首指针
    int rear;            // 队尾指针
public:
    Queue() : front(-1), rear(-1) {}  // 队列的构造函数，初始时队首和队尾指针都为 -1
    void enqueue(int element) {
        if (rear == MAX_SIZE - 1) {
            std::cout << "队满，不能入对" << std::endl;
        } else {
            if (front == -1) {
                front = 0;  // 如果队列为空，设置队首指针为0
            }
            arr[++rear] = element;  // 元素入队
        }
    }

    void dequeue() {
        if (front == -1 || front > rear) {
            std::cout << "队空，不能出队" << std::endl;
        } else {
            ++front;  // 弹出队首元素
        }
    }
    int getFront() const {
        if (front != -1 && front <= rear) {
            return arr[front];  // 返回队首元素
        } else {
            std::cout << "队空" << std::endl;
            return -1;  // 返回一个标记值表示队列为空
        }
    }
    bool isEmpty() const {
     return front == -1 || front > rear;  // 队列为空的判断条件
    }
};
int main() {
    Queue myQueue;
    for (int i = 0; i < 5; ++i) 
        myQueue.enqueue(i * 2);  // 入队
    while (!myQueue.isEmpty()) {
        int frontElement = myQueue.getFront();
        std::cout << frontElement << " ";
        myQueue.dequeue();  // 出队
    }
    return 0;
}
```

# priority_queue优先队列

## 介绍

> **优先队列 **= 正常队列 + 优先级，每次的队首元素都是最大优先级

可以实现**每次从优先队列中取出的元素都是队列中优先级最大的**一个。

> 它的底层是通过**堆**来实现的。

```cpp
//头文件
#include<queue>
//初始化定义
priority_queue<int> q;
```

## 函数方法

|       代码        |             含义             | 返回值 |
| :---------------: | :--------------------------: | :----: |
|      q.top()      |      访问队首元素 O(1)       |        |
|     q.push()      |         入队O(logN)          |        |
|      q.pop()      | 堆顶（队首）元素出队 O(logN) |        |
|     q.size()      |       队列元素个数O(1)       |        |
|     q.empty()     |        是否为空O(1）         |        |
| 注意没有clear()！ |         不提供该方法         |        |

优先队列只能通过top()访问队首元素（优先级最高的元素）	

## 设置优先级

### 基本数据类型的优先级

```cpp
priority_queue<int> pq; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue<int, vector<int>, greater<int>> q; // 小根堆, 每次取出的元素是队列中的最小值
```

### 参数解释：

#### 第一个参数：**存储的数据类型**

#### 第二个参数：

- **vector<int>** 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填**vector<double>**
- ***总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。***

#### 第三个参数：

> ​	**less<int> **表示数字大的优先级大，堆顶为最大的数字
> ​	**greater<int>**表示数字小的优先级大，堆顶为最小的数字
> ​	int代表的是数据类型，也要填优先队列中存储的数据类型

## 基础数据类型优先级设置的写法：

### 基础写法（非常常用）：

```cpp
priority_queue<int> q1; // 默认大根堆
priority_queue<int, vector<int>, less<int> > q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行
priority_queue<int, vector<int>, greater<int>> q3; // 小根堆, 每次取出的元素是队列中的最小值
```

### 自定义排序（不常见,麻烦）：

```cpp
struct cmp1 {
	bool operator()(int x, int y) {
		return x > y;//降序
	}
};
struct cmp2 {
	bool operator()(const int x, const int y) {
		return x < y;//升序
	}
};
priority_queue<int, vector<int>, cmp1> q1; // 小根堆
priority_queue<int, vector<int>, cmp2> q2; // 大根堆
```

## 高级数据类型(结构体)优先级

> 优先队列中**存储结构体类型**，必须要设置**优先级**，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。

优先级设置可以定义在**结构体内进行小于号重载**/结构体外

```cpp
//要排序的结构体（存储在优先队列里面的）
struct Point {
	int x, y;
};
```

### 版本一：自定义全局比较规则

```cpp
//定义的比较结构体
//注意：cmp是个结构体 
struct cmp {//自定义堆的排序规则 
	bool operator()(const Point& a,const Point& b) {
		return a.x < b.x;
	}
};

//初始化定义， 
priority_queue<Point, vector<Point>, cmp> q; // x大的在堆顶
```

### 版本二：直接在结构体里面写

因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。

结构体内部有两种方式：

方式一 ：

```cpp
struct node {
	int x, y;
	friend bool operator < (Point a, Point b) {//为两个结构体参数，结构体调用一定要写上friend
		return a.x < b.x;//按x从小到大排，x大的在堆顶
	}
};
```

方式二 ：（推荐此种）

```cpp
struct node {
    int x, y;
    bool operator < (const Point &a) const {//直接传入一个参数，不必要写friend
        return x < a.x;//按x升序排列，x大的在堆顶
    }
};
priority_queue<Point> q;//优先队列的定义
```

> 注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是**完全相反**的。

> 当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 > ，那么孩子节点要大于父亲节点，堆顶自然是最小值。

##  存储特殊类型的优先级

### 存储pair类型

排序规则：
	默认先对pair的first进行降序排序，然后再对second降序排序
	对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    priority_queue<pair<int, int> >q;
	q.push({7, 8});
	q.push({7, 9});
	q.push(make_pair(8, 7));
    while(!q.empty()) {
        cout << q.top().first << " " << q.top().second << "\n";
        q.pop();
    }
    return 0;
}
```

```objective-c
结果：
8 7
7 9
7 8
```

# map/multimap

##  介绍

**Map**：

所有元素都会根据元素的键值**自动排序**。Map所有的元素**都是pair**,同时拥有实值和键值，map**不允许两个元素有相同的键值**<键值，实值>，任意改变map键值将会严重破坏map组织，可改变实值

新增或者删除，操作之前的所有迭代器，完成之后依然有效，被删除的无效

Multimap和map的操作类似，唯一区别**multimap键值可重复**

Map和multimap都是以**红黑树**为底层实现机制。

```cpp
#include<map>//头文件
```

> map特性：map会按照键的顺序从小到大自动排序，键的类型必须**可以比较大小**

## 函数方法

### 构造函数

```c++
map<T1, T2> mapTT;//map默认构造函数: 
map(const map &mp);//拷贝构造函数
```

#### **map赋值操作**

```c++
map&operator=(const map &mp);//重载等号操作符
swap(mp);//交换两个集合容器
```

#### **map大小操作**

```c++
size();//返回容器中元素的数目
empty();//判断容器是否为空
```

#### **map插入数据元素操作**

```c++
map.insert(...); //往容器插入元素，返回pair<iterator,bool>
map<int, string> mapStu;
// 第一种 通过pair的方式插入对象
mapStu.insert(pair<int, string>(3, "小张"));
// 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, "校长"));
// 第三种 通过value_type的方式插入对象
mapStu.insert(map<int, string>::value_type(1, "小李"));
// 第四种 通过数组的方式插入值
mapStu[3] = "小刘";mapStu[5] = "小王";
```

#### **map删除操作**

```c++
clear();//删除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);//删除容器中key为keyElem的对组。
```

####  **map查找操作**

```c++
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end();
count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key>keyElem元素的迭代器。	
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
```

| 函数                 | 含义                                                         | 返回值 |
| -------------------- | ------------------------------------------------------------ | ------ |
| mp.find(key)         | 返回键为key的映射的迭代器 O(logN)  注意：用find函数来定位数据，当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end() |        |
| mp.erase(it)         | 删除迭代器对应的键和值O(1)                                   |        |
| mp.erase(key)        | 根据映射的键删除键和值O(logN)                                |        |
| mp.erase(first,last) | 删除[first,last)间迭代器对应的键和值 O(last−first)           |        |
| mp.size()            | 返回映射的对数O(1)                                           |        |
| mp.clear()           | 清空map中的所有元素O(N)                                      |        |
| mp.insert()          | 插入元素，插入时要构造键值对                                 |        |
| mp.empty()           | 如果map为空，返回true，否则返回false                         |        |
| mp.begin()           | 返回指向map第一个元素的迭代器（地址）                        |        |
| mp.end()             | 返回指向map尾部的迭代器（最后一个元素的下一个地址）          |        |
| mp.rbegin()          | 返回指向map最后一个元素的迭代器（地址）                      |        |
| mp.rend()            | 返回指向map第一个元素前面(上一个）的逆向迭代器（地址）       |        |
| mp.count(key)        | 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 |        |
| mp.lower_bound()     | 返回一个迭代器，指向键值>= key的第一个元素                   |        |
| mp.upper_bound()     | 返回一个迭代器，指向键值> key的第一个元素                    |        |

> **注意点**
> 查找元素**是否存在**时，可以使用
> **①mp.find() ② mp.count() ③ mp[key]**
> 但是第三种情况，如果不存在对应的**key**时，会自动创建一个**键值对**（产生一个额外的键值对空间）
> 所以为了不增加额外的空间负担，最好使用前两种方法

## **multimap案例**

```c++
//公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作
//人员信息有: 姓名 年龄 电话 工资等组成
//通过Multimap进行信息的插入 保存 显示
//分部门显示员工信息 显示全部员工信息
#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<map>
#include<string>
#include<vector>
usingnamespace std;

//multimap 案例
//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作
//人员信息有: 姓名 年龄 电话 工资等组成
//通过 Multimap 进行信息的插入 保存 显示
//分部门显示员工信息 显示全部员工信息


#define SALE_DEPATMENT 1 //销售部门
#define DEVELOP_DEPATMENT 2 //研发部门
#define FINACIAL_DEPATMENT 3 //财务部门
#define ALL_DEPATMENT 4 //所有部门

//员工类
class person{
public:
	string name;//员工姓名
	int age;//员工年龄
	double salary;//员工工资
	string tele;//员工电话
};

//创建5个员工
void CreatePerson(vector<person>& vlist){

	string seed ="ABCDE";
    	for(int i =0; i <5; i++){
		person p;
		p.name ="员工";
		p.name += seed[i];
		p.age = rand()%30+20;
		p.salary = rand()%20000+10000;
		p.tele ="010-8888888";
		vlist.push_back(p);
	}

}

//5名员工分配到不同的部门
void PersonByGroup(vector<person>& vlist, multimap<int, person>& plist){


	int operate =-1;//用户的操作

	for(vector<person>::iterator it = vlist.begin(); it != vlist.end(); it++){

		cout <<"当前员工信息:"<< endl;
		cout <<"姓名："<< it->name <<" 年龄:"<< it->age <<" 工资:"<< it->salary <<" 电话："<< it->tele << endl;
		cout <<"请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):"<< endl;
		scanf("%d",&operate);

		while(true){

			if(operate == SALE_DEPATMENT){//将该员工加入到销售部门
				plist.insert(make_pair(SALE_DEPATMENT,*it));
				break;
			}
			elseif(operate == DEVELOP_DEPATMENT){
				plist.insert(make_pair(DEVELOP_DEPATMENT,*it));
				break;
			}
			elseif(operate == FINACIAL_DEPATMENT){
				plist.insert(make_pair(FINACIAL_DEPATMENT,*it));
				break;
			}
			else{
				cout <<"您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):"<< endl;
				scanf("%d",&operate);
       			}

		}

	}
	cout <<"员工部门分配完毕!"<< endl;
	cout <<"***********************************************************"<< endl;

}

//打印员工信息
void printList(multimap<int, person>& plist,int myoperate){

	if(myoperate == ALL_DEPATMENT){
		for(multimap<int, person>::iterator it = plist.begin(); it != plist.end(); it++){
			cout <<"姓名："<< it->second.name <<" 年龄:"<< it->second.age <<" 工资:"<< it->second.salary <<" 电话："<< it->second.tele << endl;
		}
		return;
	}

	multimap<int, person>::iterator it = plist.find(myoperate);
	int depatCount = plist.count(myoperate);
	int num =0;
	if(it != plist.end()){
		while(it != plist.end()&& num < depatCount){
			cout <<"姓名："<< it->second.name <<" 年龄:"<< it->second.age <<" 工资:"<< it->second.salary <<" 电话："<< it->second.tele << endl;
			it++;
			num++;
		}
	}
}

//根据用户操作显示不同部门的人员列表
void ShowPersonList(multimap<int, person>& plist,int myoperate){

	switch(myoperate)
	{
	case SALE_DEPATMENT:
		printList(plist, SALE_DEPATMENT);
		break;
	case DEVELOP_DEPATMENT: 
            		printList(plist, DEVELOP_DEPATMENT);
		break;
	case FINACIAL_DEPATMENT:
		printList(plist, FINACIAL_DEPATMENT);
		break;
	case ALL_DEPATMENT:
		printList(plist, ALL_DEPATMENT);
		break;
	}
}

//用户操作菜单
void PersonMenue(multimap<int, person>& plist){

	int flag =-1;
	int isexit =0;
	while(true){
		cout <<"请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)："<< endl;
		scanf("%d",&flag);

		switch(flag)
		{
		case SALE_DEPATMENT:
			ShowPersonList(plist, SALE_DEPATMENT);
			break;
		case DEVELOP_DEPATMENT:
			ShowPersonList(plist, DEVELOP_DEPATMENT);
			break;
		case FINACIAL_DEPATMENT:
			ShowPersonList(plist, FINACIAL_DEPATMENT);
			break;
		case ALL_DEPATMENT:
			ShowPersonList(plist, ALL_DEPATMENT);
			break;
		case0:
			isexit =1;
			break;
		default:
			cout <<"您的输入有误，请重新输入!"<< endl;
			break;
		}

		if(isexit ==1){
            			break;
		}
	}

}

int main(){

	vector<person>  vlist;//创建的5个员工 未分组
	multimap<int, person> plist;//保存分组后员工信息

	//创建5个员工
	CreatePerson(vlist);
	//5名员工分配到不同的部门
	PersonByGroup(vlist, plist);
	//根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表
	PersonMenue(plist);

	system("pause");
	return 0;
}
```

## 迭代器进行正反向遍历

> mp.begin()和mp.end()用法：

### **用于正向遍历map**

```cpp
map<int,int> mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.begin();
while(it != mp.end()) {
	cout << it->first << " " << it->second << "\n";
	it ++;
}
```

```objective-c
结果：
1 2
2 3
3 4
```

> **mp.rbegin()和mp.rend()**

### 用于逆向遍历map

```cpp
map<int,int> mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.rbegin();
while(it != mp.rend()) {
	cout << it->first << " " << it->second << "\n";
	it ++;
}
```

```objective-c
结果：
3 4
2 3
1 2
```

## 二分查找

二分查找**lower_bound() upper_bound()**

> map的二分查找以第一个元素（即键为准），对键进行二分查找,返回值为map迭代器类型

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	map<int, int> m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序
	map<int, int>::iterator it1 = m.lower_bound(2);
	cout << it1->first << "\n";//it1->first=2
	map<int, int>::iterator it2 = m.upper_bound(2);
	cout << it2->first << "\n";//it2->first=6
	return 0;
}
```

## 添加元素

```cpp
//先声明
map<string, string> mp;
```

- 方式一：

```cpp
mp["学习"] = "看书";
mp["玩耍"] = "打游戏";
```

- 方式二：插入元素构造键值对

```cpp
mp.insert(make_pair("vegetable","蔬菜"));
```

- 方式三：

```cpp
mp.insert(pair<string,string>("fruit","水果"));
```

- 方式四:

```cpp
mp.insert({"hahaha","wawawa"});
```

## 访问元素

### 下标访问

```cpp
mp["菜哇菜"] = "强哇强";
cout << mp["菜哇菜"] << "\n";
```

### 遍历访问

#### 迭代器访问

```cpp
map<string,string>::iterator it;
for(it = mp.begin(); it != mp.end(); it++) {
	// it是结构体指针访问所以要用 -> 访问
	cout << it->first << " " << it->second << "\n";
	//*it是结构体变量 访问要用 . 访问
	//cout<<(*it).first<<" "<<(*it).second;
}
```

#### 智能指针访问

```cpp
for(auto i : mp)
cout << i.first << " " << i.second << endl;//键，值
```

#### 对指定单个元素访问

```cpp
map<char,int>::iterator it = mp.find('a');
cout << it -> first << " " <<  it->second << "\n";
```

#### c++17特性才具有

```cpp
for(auto [x, y] : mp)
	cout << x << " " << y << "\n";//x,y对应键和值
```

## 1.看容量。

```cpp
int map.size();//查询map中有多少对元素
bool empty();// 查询map是否为空
```

## 2.插入。

```cpp
map.insert(make_pair(key,value));
map.insert(pair<char, int>(key, value));
map[key]=value
```

## 3.取值。

```c++
map<int, string> map;
//如果map中没有关键字2233，使用П取值会导致插入
//园此，下面语句不会报错，但会便得输出结果结果为空
cout<<map[2233]<<end1;
//但是使用使用at会进行关键字检查，因此下面语句会报错
map.at(2016)= "Bob";
```

## 4.遍历操作

```cpp
nap<string,string>;;iterator it;
for(it= mapset,begin();it != mapset.end(); ++it){
    cout << "key"<< it->first << endl;
    cout <<"value" << it->second << endl;
}
```

## 5.查找操作

```cpp
m.count(key)://0不包含，1包含
m.find(key)://返回选代器，判断足否存有
```

## 与unordered_map的比较

### 内部实现原理

> **map：内部用红黑树实现，具有自动排序（按键从小到大）功能。**
>
> **unordered_map：内部用哈希表实现，内部元素无序杂乱。**

### 效率比较

**map：**

优点：内部用红黑树实现，内部元素有序，查询删除等操作复杂度为O(logN)

缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。

**unordered_map：**

优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。
缺点：建立哈希表比较耗时。

> 注意：
>
> 随着内部**元素越来越多**，两种容器的**插入删除查询**操作的时间都会**逐渐变大**，**效率逐渐变低**。
>
> 使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。
>
> **查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）**

```cpp
// 以 map 为例
map<int, int> mp;
int x = 999999999;
if(mp.count(x)) // 此处判断是否存在x这个键
    cout << mp[x] << "\n";   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建
```

## multimap

> 还有一种映射：multimap
>
> 键可以重复，即一个键对应多个值

# multimap 

是C++标准模板库（STL）中的一个关联容器，它允许存储键-值对，并且允许键重复。与 `std::map` 不同，`std::multimap` 中可以有多个键映射到相同的值。

以下是关于 `std::multimap` 的一些基本用法说明：

### 包含头文件

```cpp
#include <map>
```

### 创建 `multimap`

```cpp
std::multimap<int, std::string> myMultimap;
```

### 插入元素

```cpp
myMultimap.insert(std::make_pair(1, "apple"));
myMultimap.insert(std::make_pair(2, "banana"));
myMultimap.insert(std::make_pair(1, "apricot")); // 可以插入重复的键
```

### 访问元素

```cpp
// 使用迭代器遍历 multimap
for (auto it = myMultimap.begin(); it != myMultimap.end(); ++it) {
    std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
}

// 使用范围-based for 循环
for (const auto& pair : myMultimap) {
    std::cout << "Key: " << pair.first << ", Value: " << pair.second << std::endl;
}
```

### 删除元素

```cpp
// 删除指定键的所有元素
myMultimap.erase(1);

// 删除指定位置的元素
auto it = myMultimap.find(2);
if (it != myMultimap.end()) {
    myMultimap.erase(it);
}
```

### 查找元素

```cpp
auto range = myMultimap.equal_range(1);
for (auto it = range.first; it != range.second; ++it) {
    std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
}
```

### 其他操作

- `size()`: 返回 multimap 中键-值对的数量。
- `empty()`: 如果 multimap 为空则返回 true，否则返回 false。
- `clear()`: 清空 multimap 中的所有元素。

这些是关于 `std::multimap` 的基本用法说明。`std::multimap` 提供了一个方便的方法来存储多个键映射到相同值的情况。

当使用 `std::multimap` 时，你可能还需要考虑以下一些方面：

### 1. 关键字排序

默认情况下，`std::multimap` 中的元素会根据键的大小进行排序。你也可以通过提供自定义的比较函数来指定排序方式。

```cpp
std::multimap<int, std::string, std::greater<int>> myMultimap; // 按键降序排序
```

### 2. 查找元素

你可以使用 `find()` 方法来查找指定键的元素，如果键不存在，则返回 `end()` 迭代器。

```cpp
auto it = myMultimap.find(1);
if (it != myMultimap.end()) {
    // 找到了键为 1 的元素
} else {
    // 未找到键为 1 的元素
}
```

### 3. 访问元素

当有多个键映射到相同的值时，你可以使用 `equal_range()` 方法来获取所有键相同的元素的范围。

```cpp
auto range = myMultimap.equal_range(1);
for (auto it = range.first; it != range.second; ++it) {
    // 访问键为 1 的所有元素
}
```

### 4. 多键映射

`std::multimap` 允许多个键映射到相同的值，这在一些情况下可能会很有用，例如，允许多个学生拥有相同的分数。

```cpp
std::multimap<int, std::string> scores;
scores.insert({90, "Alice"});
scores.insert({80, "Bob"});
scores.insert({90, "Charlie"}); // 允许多个键映射到相同的值
```

### 5. 性能考虑

`std::multimap` 的底层实现通常是红黑树，因此插入、删除和查找操作的时间复杂度为对数级别（O(log n)）。这使得 `std::multimap` 在大多数情况下具有很好的性能。

### 6. 使用示例

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::multimap<int, std::string> scores;
    scores.insert({90, "Alice"});
    scores.insert({80, "Bob"});
    scores.insert({90, "Charlie"});
    
    for (const auto& pair : scores) {
        std::cout << "Score: " << pair.first << ", Name: " << pair.second << std::endl;
    }
    
    return 0;
}
```

# set/multiset容器

## 介绍

### （set里面的元素不重复 且有序）

- 所有元素都会根据元素的键值自动被排序。set的元素即是键值又是实值，不重复
- set元素值就是其键值，关系到set元素的排序规则，set的iterator是一种const_iterator.
- 对容器插入或者删除的时候，操作之前所有的迭代器，在完成之后依然有效，(被删除的元素的迭代器是例外)

### **multiset容器基本概念**

multiset特性及用法和set完全相同，唯一的差别在于它**允许键值重复**。set和multiset的底层实现是**红黑树**

红黑树为**平衡二叉树**的一种。

***\*二叉树示意图\****

二叉搜索树:二叉树中节点按照一定的规则进行排序，使得对二叉树中**元素访问**更加高效。

规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值

![img](file:///C:\Users\12964\AppData\Local\Temp\ksohtml10656\wps2.jpg)

## 函数方法

### set常用API.

#### **set构造函数**

```c++
set<T> st;//set默认构造函数：
mulitset<T> mst; //multiset默认构造函数: 
set(const set &st);//拷贝构造函数
```

#### **set赋值操作**

```c++
set& operator=(const set &st);//重载等号操作符
swap(st);//交换两个集合容器
```

####  **set大小操作**

```c++
size();//返回容器中元素的数目
empty();//判断容器是否为空
```

#### set插入和删除操作

```c++
insert(elem);//在容器中插入元素。
clear();//清除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);//删除容器中值为elem的元素。
```

#### set查找操作

```c++
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
	1. count(key);//查找键key的元素个数
	2. lower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。
	3. upper_bound(keyElem);//返回第一个key>keyElem元素的迭代器
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器
```

| 函数                 | 含义                                                         | 返回值 |
| -------------------- | ------------------------------------------------------------ | ------ |
| s.begin()            | 返回set容器的第一个元素的地址（迭代器）O(1)                  |        |
| s.end()              | 返回set容器的最后一个元素的下一个地址（迭代器）              |        |
| s.rbegin()           | 返回逆序迭代器，指向容器元素最后一个位置O ( 1 ) O(1)O(1)     |        |
| s.rend()             | 返回逆序迭代器，指向容器第一个元素前面的位置O ( 1 ) O(1)O(1) |        |
| s.clear()            | 删除set容器中的所有的元素,返回unsigned int类型O ( N ) O(N)O(N) |        |
| s.empty()            | 判断set容器是否为空O ( 1 ) O(1)O(1)                          |        |
| s.insert()           | 插入一个元素                                                 |        |
| s.size()             | 返回当前set容器中的元素个数O ( 1 ) O(1)O(1)                  |        |
| erase(iterator)      | 删除定位器iterator指向的值                                   |        |
| erase(first,second） | 删除定位器first和second之间的值                              |        |
| erase(key_value)     | 删除键值key_value的值                                        |        |
| 查找                 |                                                              |        |
| s.find(element)      | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |        |
| s.count(element)     | 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现 |        |
| s.lower_bound(k)     | 返回大于等于k的第一个元素的迭代器O ( l o g N ) O(logN)O(logN) |        |
| s.upper_bound(k)     | 返回大于k的第一个元素的迭代器O ( l o g N ) O(logN)O(logN)    |        |

## 访问

迭代器访问

```cpp
for(set<int>::iterator it = s.begin(); it != s.end(); it++)
	cout << *it << " ";
```

智能指针

```cpp
for(auto i : s)
	cout << i << endl;
```

访问最后一个元素

```cpp
//第一种
cout << *s.rbegin() << endl;
```

```cpp
//第二种
set<int>::iterator iter = s.end();
iter--;
cout << (*iter) << endl; //打印2;
```

```cpp
//第三种
cout << *(--s.end()) << endl;
```

## set的返回值和指定set排序规则:

```c++
//插入操作返回值
void test01(){

	set<int> s;
	pair<set<int>::iterator,bool> ret = s.insert(10);
	if(ret.second){
		cout <<"插入成功:"<<*ret.first << endl;
	}
	else{
		cout <<"插入失败:"<<*ret.first << endl;
	}
	s.insert(20);
	ret = s.insert(10);
	if(ret.second){
		cout <<"插入成功:"<<*ret.first << endl;
			}
	else{
		cout <<"插入失败:"<<*ret.first << endl;
	}

}

struct MyCompare02{
	booloperator()(int v1,int v2){
		return v1 > v2;
	}
};

//set从大到小
void test02(){

	srand((unsignedint)time(NULL));
	//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less<_Kty>
	set<int, MyCompare02> s;
	for(int i =0; i <10;i++){
		s.insert(rand()%100);
	}
	
	for(set<int, MyCompare02>::iterator it = s.begin(); it != s.end(); it ++){
		cout <<*it <<" ";
	}
	cout << endl;
}

//set容器中存放对象
class Person{
public:
	Person(string name,int age){
		this->mName = name;
		this->mAge = age;
	}
public:
	string mName;
	int mAge;
};


struct MyCompare03{
	booloperator()(const Person& p1,const Person& p2){
			return p1.mAge > p2.mAge;
	}
};

void test03(){

	set<Person, MyCompare03> s;

	Person p1("aaa",20);
	Person p2("bbb",30);
	Person p3("ccc",40);
	Person p4("ddd",50);

	s.insert(p1);
	s.insert(p2);
	s.insert(p3);
	s.insert(p4);

	for(set<Person, MyCompare03>::iterator it = s.begin(); it != s.end(); it++){
		cout <<"Name:"<< it->mName <<" Age:"<< it->mAge << endl;
	}

}
```

## 重载<运算符

### 基础数据类型

#### 改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）

```cpp
set<int> s1; // 默认从小到大排序
set<int, greater<int> > s2; // 从大到小排序
```

#### 重载运算符。（很麻烦，不太常用，没必要）

```cpp
//重载 < 运算符
struct cmp {
    bool operator () (const int& u, const int& v) const {
       // return + 返回条件
       return u > v;
    }
};
set<int, cmp> s; 

for(int i = 1; i <= 10; i++)
    s.insert(i);
for(auto i : s)
    cout << i << " ";
// 10 9 8 7 6 5 4 3 2 1
```

#### 初始化时使用匿名函数定义比较规则

```cpp
set<int, function<bool(int, int)>> s([&](int i, int j){
    return i > j; // 从大到小
});
for(int i = 1; i <= 10; i++)
    s.insert(i);
for(auto x : s)
    cout << x << " ";
```

### 高级数据类型（结构体）

```cpp
struct Point {
	int x, y;
	bool operator < (const Point &p) const {
		// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大
		if(x == p.x)
			return y < p.y;
		return x < p.x;
	}
};

set<Point> s;
for(int i = 1; i <= 5; i++) {
    int x, y;
    cin >> x >> y;
    s.insert({x, y});
}	
/* 输入
5 4
5 2
3 7
3 5
4 8
*/

for(auto i : s)
    cout << i.x << " " << i.y << "\n";
/* 输出
3 5
3 7
4 8
5 2
5 4
*/
```

## 其它set

unordered_set ：元素无序且只能出现一次

unordered_multiset ： 元素无序可以出现多次

# string

## 介绍

`string` 是一个字符串类，类似于 `char` 型字符串。

可以将 `string` 理解为一个字符串类型，像 `int` 一样可以定义。

### 初始化及定义

```cpp
// 头文件
#include<string>

// 1.
string str1; // 生成空字符串

// 2.
string str2("123456789"); // 生成 "1234456789" 的复制品 

// 3.
string str3("12345", 0, 3); // 结果为 "123" ，从 0 位置开始，长度为 3

// 4.
string str4("123456", 5); // 结果为 "12345" ，长度为 5

// 5.
string str5(5, '2'); // 结果为 "22222" ，构造 5 个字符 '2' 连接而成的字符串

// 6.
string str6(str2, 2); // 结果为 "3456789"，截取第三个元素（2 对应第三位）到最后
```

### 简单使用

#### 访问单个字符

```cpp
#include<iostream>
#include<string>
using namespace std;
int main() {
    string s = "lp !!!";
    for(int i = 0; i < s.size(); i++)
        cout << s[i] << " ";
    return 0;
}
```

#### string 数组使用

```cpp
#include<iostream>
#include<string>
using namespace std;
int main() {
    string s[10];
    for(int i = 1; i < 10; i++) {
        s[i] = "loading...  ";
        cout << s[i] << i << "\n";
    } 
    return 0;
}
```

### string 特性

- 支持比较运算符：`>`, `>=`, `<`, `<=`, `==`, `!=`
- 支持 `+` 运算符，代表拼接字符串

### 读入详解

- 读入字符串，遇空格、回车结束
- 读入一行字符串（包括空格），遇回车结束

### cin 与 cout 解锁

```cpp
ios::sync_with_stdio(false);
cin.tie(0), cout.tie(0);
```

### string 与 C 语言字符串（C-string）的区别

- `string` 是 C++ 的一个类，专门实现字符串的相关操作，具有丰富的操作方法，数据类型为 `string`，字符串结尾没有 `\0` 字符。
- C-string 是 C 语言中的字符串，用 `char` 数组实现，类型为 `const char *`，字符串结尾以 `\0` 结尾。

### 函数方法

- 获取字符串长度：
  - `s.size()` 和 `s.length()`：返回 `string` 对象的字符个数，执行效果相同。
  - `s.max_size()`：返回 `string` 对象最多包含的字符数，超出会抛出 `length_error` 异常。
  - `s.capacity()`：重新分配内存之前，`string` 对象能包含的最大字符数。
- 插入：
  - `s.push_back()`：在末尾插入。
  - `s.insert(pos, element)`：在 `pos` 位置插入 `element`。
  - `s.append(str)`：在 `s` 字符串结尾添加 `str` 字符串。
- 删除：
  - `erase(iterator p)`：删除字符串中 `p` 所指的字符。
  - `erase(iterator first, iterator last)`：删除字符串中迭代器区间 `[first, last)` 上所有字符。
  - `erase(pos, len)`：删除字符串中从索引位置 `pos` 开始的 `len` 个字符。
  - `clear()`：删除字符串中所有字符。
- 字符替换：
  - `s.replace(pos, n, str)`：把当前字符串从索引 `pos` 开始的 `n` 个字符替换为 `str`。
  - `s.replace(pos, n, n1, c)`：把当前字符串从索引 `pos` 开始的 `n` 个字符替换为 `n1` 个字符 `c`。
  - `s.replace(it1, it2, str)`：把当前字符串 `[it1, it2)` 区间替换为 `str`，`it1`、`it2` 为迭代器。
- 大小写转换：
  - `tolower(s[i])`：转换为小写。
  - `toupper(s[i])`：转换为大写。

### 分割

- `s.substr(pos, n)`：截取从 `pos` 索引开始的 `n` 个字符。

### 查找

- `s.find(str, pos)`：在当前字符串的 `pos` 索引位置开始，查找子串 `str`，返回找到的位置索引，-1 表示查找不到子串。
- `s.rfind(str, pos)`：在当前字符串的 `pos` 索引位置开始，反向查找子串 `str`，返回找到的位置索引，-1 表示查找不到子串。

### 排序

```cpp
sort(s.begin(), s.end()); // 按 ASCII 码排序
```

# bitset

## 介绍

`bitset` 在 `bitset` 头文件中，它类似数组，并且每一个元素只能是 0 或 1，每个元素只用 1 bit 空间。

### 初始化定义
初始化方法：

```cpp
bitset < n >a	//a有n位，每位都为0
bitset < n >a(b)	//a是unsigned long型u的一个副本
bitset < n >a(s)	//a是string对象s中含有的位串的副本
bitset < n >a(s,pos,n)	//a是s中从位置pos开始的n个位的副本
```

注意：`n` 必须为常量表达式。

演示代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    bitset<4> bitset1;     // 无参构造，长度为 4，默认每一位为 0
    bitset<9> bitset2(12); // 长度为 9，二进制保存，前面用 0 补充
    string s = "100101";
    bitset<10> bitset3(s); // 长度为 10，前面用 0 补充
    char s2[] = "10101";
    bitset<13> bitset4(s2);    // 长度为 13，前面用 0 补充
    cout << bitset1 << endl;    // 0000
    cout << bitset2 << endl;    // 000001100
    cout << bitset3 << endl;    // 0000100101
    cout << bitset4 << endl;    // 0000000010101
    return 0;
}
```

### 特性

`bitset` 可以进行位操作。

```cpp
bitset<4> foo(string("1001"));
bitset<4> bar(string("0011"));

cout << (foo^=bar) << endl;   // 1010 (foo 对 bar 按位异或后赋值给 foo)
cout << (foo&=bar) << endl;   // 0001 (按位与后赋值给 foo)
cout << (foo|=bar) << endl;   // 1011 (按位或后赋值给 foo)
cout << (foo<<=2) << endl;    // 0100 (左移 2 位，低位补 0，有自身赋值)
cout << (foo>>=1) << endl;    // 0100 (右移 1 位，高位补 0，有自身赋值)
cout << (~bar) << endl;       // 1100 (按位取反)
cout << (bar<<1) << endl;     // 0110 (左移，不赋值)
cout << (bar>>1) << endl;     // 0001 (右移，不赋值)
cout << (foo==bar) << endl;   // false (1001 == 0011 为 false)
cout << (foo!=bar) << endl;   // true  (1001 != 0011 为 true)
cout << (foo&bar) << endl;    // 0001 (按位与，不赋值)
cout << (foo|bar) << endl;    // 1011 (按位或，不赋值)
cout << (foo^bar) << endl;    // 1010 (按位异或，不赋值)
```

### 访问
可以通过 `[]` 访问元素（类似数组），注意最低位下标为 0。

```cpp
bitset<4> foo("1011"); 
cout << foo[0] << endl;    // 1
cout << foo[1] << endl;    // 0
cout << foo[2] << endl;    // 1
```

### 方法函数

```cpp
b.any()	b中是否存在置为1的二进制位，有 返回true
b.none()	b中是否没有1，没有 返回true
b.count()	b中为1的个数
b.size()	b中二进制位的个数
b.test(pos)	测试b在pos位置是否为1，是 返回true
b[pos]	返回b在pos处的二进制位
b.set()	把b中所有位都置为1
b.set(pos)	把b中pos位置置为1
b.reset()	把b中所有位都置为0
b.reset(pos)	把b中pos位置置为0
b.flip()	把b中所有二进制位取反
b.flip(pos)	把b中pos位置取反
b.to_ulong()	用b中同样的二进制位返回一个unsigned long值
```

# STL函数

> 以下出现的描述说明：（下面函数排序按**字典序排列**）
>
> `beg`为序列的初始地址
>
> `end`为序列的尾地址

## accumulate

```cpp
accumulate(beg, end, init);//accumulate(开始, 结束, 初始值);   返回值为与init相同的求和结果
```

复杂度：O(N)

> **作用：对一个序列的元素求和**

- 基础累加求和：

```cpp
int a[]={1, 3, 5, 9, 10};
int res1 = accumulate(a, a + 3, 0);//对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9
int res2 = accumulate(a, a + 4, 5);//对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23
```

- 自定义二元对象求和：使用lambda表达式

```cpp
typedef long long ll;
struct node {
    ll num;
} st[10];
for(int i = 1; i <= n; i++)	st[i].num = i + 10000000000;
//返回值类型与init一致，同时注意参数类型（a）也要一样
//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007
ll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b) {return a + b.num;});
					[st + 1, st + 4)
```

## atoi

```cpp
atoi(const char *)
```

> 将字符串转换为int类型

注意参数为char型数组，如果需要将string类型转换为int类型，可以使用stoi函数（参考下文），或者将string类型转换为const char *类型。

关于输出数字的范围：
atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。
stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。

```cpp
string s = "1234";
int a = atoi(s.c_str());
cout << a << "\n"; // 1234
```

或者

```cpp
char s[] = "1234";
int a = atoi(s);
cout << a << "\n";//1234
```

## fill

```cpp
fill(beg, end, num);//对一个序列进行初始化赋值
```

复杂度：O(N)

```cpp
//对a数组的所有元素赋1
int a[5];
fill(a, a + 5, 1);
for(int i = 0; i < 5; i++)
    cout << a[i] << " ";//1 1 1 1 1
```

注意区分memset：

memset()是按字节进行赋值，对于初始化赋0或-1有比较好的效果.

如果赋某个特定的数会出错，赋值特定的数建议使用fill()

## memset

`memset` 函数是一个用于设置一块内存内容的C标准库函数。它通常用于将一定数量的字节设置为特定的值。函数的声明如下：

```c
void *memset(void *ptr, int value, size_t num);
```

其中：

- `ptr` 是指向要设置的内存块的指针。
- `value` 是要设置的值，通常以整数表示。
- `num` 是要设置的字节数。

`memset` 的作用是将 `ptr` 指向的内存块的前 `num` 个字节的内容设置为 `value`。

以下是一个简单的示例，演示如何使用 `memset`：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[20];

    // 将 str 数组的前10个字节设置为 'A'
    memset(str, 'A', 10);

    // 打印结果
    printf("After memset: %s\n", str);

    return 0;
}
```

在这个例子中，`memset` 被用来将字符数组 `str` 的前10个字节设置为字符 `'A'`。这会将数组的内容修改为 "AAAAAAAAAA"。

## is_sorted

```cpp
is_sorted(beg, end);//判断序列是否有序(默认检验升序)，返回bool值
```

复杂度：O(N)

```cpp
//如果序列有序，输出YES
if(is_sorted(a, a + n))
    cout << "YES\n";
```

**使用 `std::is_sorted` 检查一个范围是否按照降序排列：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
// 比较函数，用于降序排序
bool compareDescending(int a, int b) {return a > b;}
int main() {
    std::vector<int> vec = {5, 4, 3, 2, 1};
    // 使用 std::is_sorted 检查是否按照降序排列
    if (std::is_sorted(vec.begin(), vec.end(), compareDescending)) {std::cout << "数组降序";
    } else {std::cout << "数组升序";}
    return 0;
}
```

在这个例子中，`compareDescending` 函数被传递给 `std::is_sorted`，以指定降序排序的比较方式

## iota

```cpp
iota(beg, end ,value);//让序列递增赋值
     开始,结束, 初始值
```

```cpp
vector<int> a(10);
iota(a.begin(), a.end(), 0);
for(auto i : a)	cout << i << " ";// 0 1 2 3 4 5 6 7 8 9
```

## lower_bound + upper_bound

复杂度：O(logN)

头文件：

```cpp
#include <algorithm>
```

> 作用：二分查找

### `lower_bound` 函数

`lower_bound` 函数用于在有序序列中查找第一个不小于某个值的元素的位置。它返回一个迭代器

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 4, 4, 4, 6, 7};
    // 在有序序列中查找第一个不小于 5 的位置
    auto it = std::lower_bound(vec.begin(), vec.end(), 5);
    // 输出结果
    if (it != vec.end()) {
        std::cout << "First element not less than 5 is: " << *it << std::endl;
    } else {
        std::cout << "No such element found." << std::endl;
    }
    return 0;
}
```

在这个例子中，`lower_bound` 将在有序向量 `vec` 中查找第一个不小于 5 的位置，输出结果是 `6`。

### `upper_bound` 函数

`upper_bound` 函数用于在有序序列中查找第一个大于某个值的元素的位置。它返回一个迭代器，该迭代器指向序列中的第一个大于给定值的元素。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 4, 4, 4, 6, 7};

    // 在有序序列中查找第一个大于 4 的位置
    auto it = std::upper_bound(vec.begin(), vec.end(), 4);

    // 输出结果
    if (it != vec.end()) {
        std::cout << "First element greater than 4 is: " << *it << std::endl;
    } else {
        std::cout << "No such element found." << std::endl;
    }

    return 0;
}
```

在这个例子中，`upper_bound` 将在有序向量 `vec` 中查找第一个大于 4 的位置，输出结果是 `6`。

### `equal_range` 函数

此外，还有一个函数 `equal_range`，它返回一个范围，表示等于给定值的元素的范围。返回值是一个 `std::pair`，其中 `first` 是指向范围开始的迭代器，`second` 是指向范围结束的下一个位置的迭代器。如果没有找到匹配的元素，那么 `first` 和 `second` 都指向插入位置。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 4, 4, 4, 6, 7};
    // 在有序序列中查找值为 4 的元素范围
    auto range = std::equal_range(vec.begin(), vec.end(), 4);
    // 输出结果
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在这个例子中，`equal_range` 将查找值为 4 的元素范围，输出结果是 `4 4 4`。

## max_element+min_element

复杂度：O(N)

> 找最大最小值

```cpp
//函数都是返回地址，需要加*取值
int mx = *max_element(a, a + n);
int mn = *min_element(a, a + n);
```

## max+min

复杂度：O(1)

> 找多个元素的最大值和最小值

```cpp
//找a，b的最大值和最小值
mx = max(a, b);
mn = min(a, b);
```

```cpp
//找到a,b,c,d的最大值和最小值
mx = max({a, b, c, d});
mn = min({a, b, c, d});
```

## minmax

```cpp
minmax(a, b);//返回一个pair类型，第一个元素是min(a, b)， 第二个元素是max(a, b)
```

复杂度：O(1)

```cpp
pair<int,int> t = minmax(4, 2);// t.first = 2, t.second = 4
```

## minmax_element

```cpp
minmax_element(beg, end)
```

复杂度：O(N)

> 返回序列中的最小和最大值组成pair的对应的地址，返回类型为pair<vector<int>::iterator, vector<int>::iterator>

```cpp
int n = 10;
vector<int> a(n);
iota(a.begin(), a.end(), 1);
auto t = minmax_element(a.begin(), a.end()); // 返回的是最小值和最大值对应的地址
// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针
```

## nth_element

```cpp
nth_element(beg, nth, end);//寻找第序列第n小的值
```

复杂度： 平均O(N)

nth为一个迭代器，指向序列中的一个元素。第n小的值恰好在nth位置上。

执行nth_element()之后，序列中的元素会围绕nth进行划分：nth之前的元素都小于等于它，而之后的元素都大于等于它

`nth_element` 是C++标准库中的一个算法，用于对一个范围进行部分排序。具体而言，它将范围 `[beg, end)` 中的第 `nth` 个元素放置在它在完全排序的情况下应该处于的位置，而范围内的其他元素则可能出现在任意顺序中。

函数签名如下：

```cpp
template<class RandomIt>
void nth_element(RandomIt beg, RandomIt nth, RandomIt end);
```

其中：

- `beg` 是范围的起始迭代器。
- `nth` 是指向第 `nth` 个元素的迭代器。
- `end` 是范围的结束迭代器。

`nth_element` 的实现使用了类似快速排序的分割算法，但不会完全排序整个范围，而是将第 `nth` 个元素放在正确的位置上。

以下是一个简单的示例：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> vec = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};2 3 5 6 7 9 10 11 12 14
    // 将第5个元素放置在正确位置
    std::nth_element(vec.begin(), vec.begin() + 4, vec.end());
    // 输出结果
    std::cout << "The fifth element: " << vec[4] << std::endl;
    // 输出完整范围
    std::cout << "Partial sorted range: ";
    for (const auto &element : vec) {
        std::cout << element << " ";
    }
    return 0;
}
```

在这个例子中，`nth_element` 将第5个元素（实际上是第6个最小的元素）放在了正确的位置上。输出结果可能是类似这样的顺序：`6 3 5 2 9 10 14 11 12 7`，其中第5个元素是9。

`nth_element` 主要用于在不需要完全排序整个范围的情况下找到范围中的第 `nth` 个元素。这在一些特定的应用场景中可以提高效率。

## next_permutation

```cpp
next_permutation(beg, end);//求序列的下一个排列，下一个排列是字典序大一号的排列返回true或false
```

复杂度:O(N)

```cpp
next_permutation(beg, end);
```

如果是最后一个排列，返回false,否则求出下一个序列后，返回true

```cpp
//对a序列进行重排
next_permutation(a, a + n);
```

应用：求所有的排列

输出a的所有排列

```cpp
// 数组a不一定是最小字典序序列，一定注意将它排序
sort(a, a + n);
do {
 	for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
} while(next_permutation(a, a + n));
```

prev_permutation(beg, end)
求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false

## partial_sort

```cpp
partial_sort(beg, mid, end)
```


复杂度： 大概O ( N l o g M ) O(N logM)O(NlogM) M为距离

部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置

从beg到mid前的元素都排好序

对a数组前5个元素排序按从小到大排序

```cpp
int a[] = {1,2,5,4,7,9,8,10,6,3};
partial_sort(a, a + 5, a + 10);
for(int i = 0; i < 10; i++) 
    cout << a[i] << ' ';
//1 2 3 4 5 9 8 10 7 6
//前五个元素都有序
```

也可以添加自定义排序规则：

```cpp
partial_sort(beg,mid,end,cmp)
```

对a的前五个元素都是降序排列

```cpp
int a[] = {1,2,5,4,7,9,8,10,6,3};
partial_sort(a, a + 5, a + 10, greater<int>());
for(int i = 0; i < 10; i++) 
    cout << a[i] << ' ';
//10 9 8 7 6 1 2 4 5 3
//前五个元素降序有序
```

## random_shuffle

复杂度： O ( N ) O(N)O(N)

随机打乱序列的顺序
random_shuffle 在 C++14 中被弃用，在 C++17 中被废除，C++11之后应尽量使用shuffle来代替。

```cpp
vector<int> b(n);
iota(b.begin(), b.end(), 1);// 序列b递增赋值 1, 2, 3, 4,...
// 对a数组随机重排
random_shuffle(a, a + n);
// C++11之后尽量使用shuffle
shuffle(b.begin(), b.end());
```

## reverse

```cpp
reverse(beg,end)
```

复杂度： O ( N ) O(N)O(N)

对序列进行翻转

```cpp
string s = "abcde";
reverse(s.begin(), s.end());//对s进行翻转
cout << s << '\n';//edcba

//对a数组进行翻转
int a[] = {1, 2, 3, 4};
reverse(a, a + 4);
cout << a[0] << a[1] << a[2] << a[3];//4321
```

## set_union, set_intersection,set_difference

复杂度： O ( N + M ) O(N+M)O(N+M)

求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。

注意：两个集合必须为有序集合，所以下面演示代码使用了排序。vector容器可以替换成set容器，因为set自动会对元素进行排序。

函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。

```cpp
vector<int> a = {4, 5, 2, 1, 8}, b = {5, 3, 8, 9, 2};
sort(a.begin(), a.end()); // 1 2 4 5 8
sort(b.begin(), b.end()); // 2 3 5 8 9
vector<int> c, d, e;
// a并b：1 2 3 4 5 8 9
set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(c, c.begin()));
// a交b：2 5 8
set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(d, d.begin()));
// a差b： 1 4
set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(e, e.begin()));
```

## sort

复杂度： O ( N l o g N ) O(N logN)O(NlogN)

作用：对一个序列进行排序

```cpp
//原型：
sort(beg, end);
sort(beg, end, cmp);
```

几种排序的常见操作：

操作一：对数组正常升序排序

```cpp
int a[N]; // 普通数组定义
// 对 a 数组的[1, n]位置进行从小到大排序
sort(a + 1, a + 1 + n);
```

```cpp
vector<int> b(n + 1); // vector数组定义
sort(b.begin() + 1, b.end());
操作二：使用第三个参数，进行降序排序
//对a数组的[0, n-1]位置从大到小排序
sort(a, a + n, greater<int>());
//对a数组的[0, n-1]位置从小到大排序
sort(a, a + n, less<int>());

vector<int> b(n + 1);
sort(b.begin() + 1, b.end()); // 升序
sort(b.begin() + 1, b.end(), greater<int>()); // 降序
操作三：另外一种降序排序方法，针对 vector
vector<int> a(n);
sort(a.rbegin(), a.rend()); // 使用反向迭代器进行降序排序
```

操作四：自定义排序规则

```cpp
// 1. 使用函数自定义排序，定义比较函数
bool cmp(node a, node b) {
    //按结构体里面的x值降序排列
    return a.x > b.x;
}
sort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则

// 2. 或者使用匿名函数自定义排序规则
sort(node, node + n, [](node a, node b) {
    return a.x > b.x;
});
```

## stable_sort

复杂度： O ( N l o g N ) O(N logN)O(NlogN)

功能和 sort() 基本一样

区别在于stable_sort()能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置

使用用法和sort()一样，见上

stoi
stoi(const string*)
1
将对应string类型字符串转换为数字，记忆：s -> t 分别对应两个数据类型的某个字母

注意参数为string字符串类型。

关于输出数字的范围：

stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。

atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。

```cpp
string s = "1234";
int a = stoi(s);
cout << a << "\n"; // 1234
```

## transform

复杂度： O ( N ) O(N)O(N)

作用：使用给定操作，将结果写到dest中

```cpp
//原型：
transform(beg, end, dest, unaryOp);
```

一般不怎么使用，徒增记忆负担，不如手动实现。

```cpp
//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中
transform(beg, end, dest, ::tolower);
transform(beg, end, dest, ::toupper);
```

## to_string

将数字转化为字符串，支持小数（double）

```cpp
int a = 12345678;
cout << to_string(a) << '\n';
```



## unique

```cpp
unique(beg, end)
```

复杂度： O ( N ) O(N)O(N)

消除重复元素，返回消除完重复元素的下一个位置的地址

如：a[] = {1, 3, 2, 3, 6};

unique 之后 a 数组为{1, 2, 3, 6, 3}前面为无重复元素的数组，后面则是重复元素移到后面，返回a[4]位置的地址（不重复元素的尾后地址）

消除重复元素一般需要原序列是有序序列

应用：离散化

方法一：利用数组离散化

```cpp
for(int i = 0; i < n; i++) {
    cin >> a[i];
    b[i] = a[i];//将a数组复制到b数组
}
// 排序后 b：{1, 2, 3, 3, 6}
sort(b, b + n);//对b数组排序
// 消除重复元素b：{1, 2, 3, 6, 3} 返回的地址为最后一个元素3的地址 
int len = unique(b, b + n) - b;//消除 b 的重复元素，并获取长度
for(int i = 0; i < n; i++) {
    //因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）
    int pos = lower_bound(b, b + len, a[i]) - b;//在b数组中二分查找第一个大于等于a[i]的下标
    a[i] = pos; // 离散化赋值
}
```

方法二：利用 vector 进行离散化

```cpp
vector<int> a(n);
for (int i = 0; i < n; ++i) {
    cin >> a[i];
}
vector<int> b = a;
sort(b.begin(), b.end());
b.erase(unique(b.begin(), b.end()), b.end());
for (int i = 0; i < n; ++i) {
	a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1; // 离散后的数据从1开始   
}
```

## _gcd

```cpp
_gcd(a, b);
```

求a和b的最大公约数

```cpp
_gcd(12,15) = 3;
_gcd(21,0) = 21;
```

## _lg

```cpp
_lg(a)
```

求一个数二进制下最高位位于第几位（从第0位开始）（或二进制数下有几位）
__lg(x)相当于返回⌊ l o g 2 x ⌋ \lfloor log_2 x \rfloor⌊log 
2

 x⌋
复杂度O ( 1 ) O(1)O(1)
__lg(8) = 3

__lg(15) = 3

_builtin 内置位运算函数
需要注意：内置函数有相应的unsigned lnt和unsigned long long版本，unsigned long long只需要在函数名后面加上ll就可以了，比如__builtin_clzll(x) ，默认是32位unsigned int

很多题目和 long long 数据类型有关，如有需要注意添加 ll

## __builtin_ffs

__builtin_ffs(x)
1
二进制中对应最后一位1的位数，比如4会返回3（100）

## __builtin_popcount

__builtin_popcount(x)
1
x中1的个数

## __builtin_ctz

__builtin_ctz(x)
1
x末尾0的个数（count tail zero）

## __builtin_clz

__builtin_clz(x)
1
x前导0的个数（count leading zero）

cout << __builtin_clz(32); // 26
//因为共有6位,默认数据范围为32位，32 - 6 = 26__builtin_parity
__builtin_parity(x)
x中1的个数的奇偶性， 奇数输出1，偶数输出0

# **STL容器元素深/浅拷贝问题**

STL容器所提供的都是值(value)，而非引用(reference)，即当我们给容器中插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中，也就是说**我们提供的元素必须能够被拷贝**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
usingnamespace std;

class myclass{
public:
	myclass(char* data){
			int len = strlen(data)+1;//计算传进来的字符串长度
		this->data =newchar[len];//在堆区分配了len字节内存
		strcpy(this->data, data);//将数据拷贝到我们在堆分配的内存中
	}
	//增加拷贝构造函数
	myclass(const myclass& mc){
		int len = strlen(mc.data)+1;
		this->data =newchar[len];
		strcpy(this->data, mc.data);
	}
	//重载operator=操作符
	myclass&operator=(const myclass& mc){

       if (this->data != NULL){
			delete[] this->data;
			this->data = NULL;
		}

		int len = strlen(mc.data)+1;
		this->data =newchar[len];
		strcpy(this->data, mc.data);
		return*this;
	}
	//既然我们在堆区分配了内存，需要在析构函数中释放内存
	~myclass(){
		if(NULL!=this->data){
			delete[]this->data;
			this->data =NULL;
		}
	}
private:
	char* data;
};

void test_deep_copy(){
	char* data ="abcd";
	myclass mc(data);//创建myclass的实例 并用char*字符串data初始化对象

	vector<myclass> v;//创建vector容器
	v.push_back(mc);//将mc实例插入到vector容器尾部

}
int main(){
	test_deep_copy();//调用测试函数
	return0;
}
```



#  STL容器使用时机

|              | vector   | deque    | list     | set    | multiset | map             | multimap      |
| ------------ | -------- | -------- | -------- | ------ | -------- | --------------- | ------------- |
| 典型内存结构 | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树          | 二叉树        |
| 可随机存取   | 是       | 是       | 否       | 否     | 否       | 对key而言：不是 | 否            |
| 元素搜寻速度 | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言：快   | 对key而言：快 |
| 元素安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -               | -             |

- vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。

- deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。

vector与deque的比较：

​	一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置	却是不固定的。

​	二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。

​	三：deque支持头部的快速插入与快速移除，这是deque的优点。

- list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。
- set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 
- map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。

# 常用算法

## 函数对象

重载函数调用操作符的类，其对象常称为**函数对象**（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。

注意:

​	1.函数对象(仿函数)是**一个类**，不是一个函数。

​	2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。

​	分类:

类重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；

相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。

```c++
//函数对象是重载了函数调用符号的类
struct MyPrint{
	voidoperator()(int val){
		cout << val << endl;
	}
};
void test01(){
	//如何使用
	MyPrint print01;
	print01(10);//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值
}
//函数对象超出了普通函数的概念，可以保存函数的调用状态
struct HePrint{
	HePrint(){
		mCount =0;
	}
	voidoperator()(int val){
		cout << val << endl;
		mCount++;
	}
	int mCount;
};
void test02(){
	HePrint print;
	print(10);
	print(20);
	print(30);
	print(40);
	cout << print.mCount << endl;
}
//函数对象可以做参数和返回值
struct OurPrint{
	voidoperator()(int val){
			cout << val << endl;
	}
};
void doBusiness(OurPrint print){
	print(20);
}
void test03(){
	//函数对象做参数
	doBusiness(OurPrint());
}
```

 

## 谓词

谓词是指**普通函数**或**重载的operator()**返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做**一元谓词**,如果接受两个参数，那么叫做**二元谓词**，谓词可作为一个判断式。

```c++
struct GreaterThanFive{
	booloperator()(int v){
		return v >5;
	}
};

//一元谓词
void test01(){
	
	vector<int> v;
	for(int i =0; i <10;i++){
		v.push_back(i);
	}

	vector<int>::iterator ret = find_if(v.begin(), v.end(), GreaterThanFive());
	if(ret == v.end()){
		cout <<"没有找到!"<< endl;
	}
	else{
		cout <<"找到:"<<*ret << endl;
			}

}

//二元谓词
struct MyCompare{
	booloperator()(int v1,int v2){
		return v1 > v2;
	}
};

void test02(){

	vector<int> v;
	srand((unsignedint)time(NULL));
	for(int i =0; i <10; i++){
		v.push_back(rand()%100);
	}

	for(vector<int>::iterator it = v.begin(); it != v.end(); it ++){
		cout <<*it <<" ";
	}
	cout << endl;
	//排序算法
	sort(v.begin(), v.end(), MyCompare());

	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout <<*it <<" ";
	}
	cout << endl;
}
```

 

##  内建函数对象

STL内建了一些函数对象。分为:**算数类函数对象**,**关系运算类函数对象**，**逻辑运算类仿函数**。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include<functional>。

- 6个算数类函数对象,除了negate是一元运算，其他都是二元运算。

```c++
template<classT>T plus<T>//加法仿函数
template<class T> T minus<T>//减法仿函数
template<class T> T multiplies<T>//乘法仿函数
template<class T> T divides<T>//除法仿函数
template<class T> T modulus<T>//取模仿函数
template<class T> T negate<T>//取反仿函数
```

- 6个关系运算类函数对象,每一种都是二元运算。

```c++
template<class T>bool equal_to<T>//等于
template<class T>bool not_equal_to<T>//不等于
template<class T>bool greater<T>//大于
template<class T>bool greater_equal<T>//大于等于
template<class T>bool less<T>//小于
template<class T>bool less_equal<T>//小于等于
```

- 逻辑运算类运算函数,not为一元运算，其余为二元运算。

```c++
template<class T>bool logical_and<T>//逻辑与
template<class T>bool logical_or<T>//逻辑或
template<class T>bool logical_not<T>//逻辑非
```

内建函数对象举例:

```c++
/*
template<class T> bool equal_to<T>//等于
template<class T> bool not_equal_to<T>//不等于
template<class T> bool greater<T>//大于
template<class T> bool greater_equal<T>//大于等于
template<class T> bool less<T>//小于
template<class T> bool less_equal<T>//小于等于
*/

void test01(){

	equal_to<int> MyEqual;
	plus<int> MyPlus;
	if(MyEqual(10,20)){
		cout <<"相等!"<< endl;
	}
	else{
		cout <<"不相等!"<< endl;
	}
		cout <<"MyPlus:"<< MyPlus(10,20)<< endl;

}

void test02(){
	
	vector<int> v;
	srand((unsignedint)time(NULL));
	for(int i =0; i <10; i++){
		v.push_back(rand()%100);
	}

	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout <<*it <<" ";
	}
	cout << endl;
	sort(v.begin(),v.end(),greater<int>());

	for(vector<int>::iterator it = v.begin(); it != v.end(); it++){
		cout <<*it <<" ";
	}
	cout << endl;

}
```

 

### 函数对象适配器

```c++
//函数适配器bind1st bind2nd
//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做哇？
struct myprint :public binary_function<int,int,void>{//二元函数对象 所以需要继承 binary_fucntion<参数类型,参数类型,返回值类型>
	voidoperator()(int v1,int v2)const{
		cout << v1 + v2 <<" ";
	}
};
void test02(){

	vector<int> v;
	v.push_back(1);
		v.push_back(2);
	v.push_back(3);
	v.push_back(4);

	//我们直接给函数对象绑定参数 编译阶段就会报错
	//for_each(v.begin(), v.end(), bind2nd(myprint(),100));
	//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function
	//根据我们函数对象是一元函数对象 还是二元函数对象
	for_each(v.begin(), v.end(), bind2nd(myprint(),100));
	cout << endl;

	//总结：  bind1st和bind2nd区别?
	//bind1st ： 将参数绑定为函数对象的第一个参数
	//bind2nd ： 将参数绑定为函数对象的第二个参数
	//bind1st ,bind2nd将二元函数对象转为一元函数对象
}

//函数对象适配器 not1 not2
struct myprint02 {
	voidoperator()(int v1)const{
		cout << v1 <<" ";
	}
};
void test03(){

	vector<int> v;
	v.push_back(2);
	v.push_back(1);
	v.push_back(5);
	v.push_back(4);

	vector<int>::iterator it = find_if(v.begin(), v.end(), not1(bind2nd(less_equal<int>(),2)));
	cout <<"it:"<<*it << endl;
	sort(v.begin(), v.end(), not2(greater<int>()));

	for_each(v.begin(), v.end(), myprint02());
	cout << endl;

	//not1 对一元函数对象取反
	//not2 对二元函数对象取反
}
//如何给一个普通函数使用绑定适配器(bind1st bind2nd)绑定一个参数？(拓展)
//ptr_fun
void myprint04(int v1,int v2){
	cout << v1 + v2 <<" ";
}
void test04(){

	vector<int> v;
	v.push_back(2);
	v.push_back(1);
	v.push_back(5);
	v.push_back(4);


	//1 将普通函数适配成函数对象
	//2 然后通过绑定器绑定参数
	for_each(v.begin(), v.end(), bind2nd(ptr_fun(myprint04),100));
	cout << endl;

	//总结: ptr_fun 将普通函数转变为函数对象
}

//mem_fun mem_fun_ref
//如果我们容器中存储的是对象或者对象指针，如果能指定某个成员函数处理成员数据。
class student{
public:
	student(string name,int age):name(name), age(age){}
	void print(){
		cout <<"name:"<< name <<" age:"<< age << endl;;
	}
	void print2(int a){
		cout <<"name:"<< name <<" age:"<< age <<" a:"<< a << endl;
	}
	int age;
	string name;
};
void test05(){

	//mem_fun : 如果存储的是对象指针，需要使用mem_fun
	vector<student*> v;
	student* s1 =new student("zhaosi",10);
	student* s2 =new student("liuneng",20);
	student* s3 =new student("shenyang",30);
	student* s4 =new student("xiaobao",40);
	
	v.push_back(s1);
	v.push_back(s2);
	v.push_back(s3);
	v.push_back(s4);

	for_each(v.begin(), v.end(), mem_fun(&student::print));
	cout <<"-----------------------------"<< endl;

	//mem_fun_ref : 如果存储的是对象，需要使用mem_fun_ref

	vector<student> v2;
	v2.push_back(student("zhaosi",50));
	v2.push_back(student("liuneng",60));
	v2.push_back(student("shenyang",70));
	v2.push_back(student("xiaobao",80));

	for_each(v2.begin(), v2.end(), mem_fun_ref(&student::print));

}
```

# 空间配置器

## 容器通过空间配置器取得数据存储空间,空间配置器管理容器的空间

## STL空间配置器产生的缘由：

　　在软件开发中，我们不免因为程序需求，使用很多的小块内存（基本类型以及小内存的自定义类型）。在程序中动态申请，释放。

这个过程过程并不是一定能够控制好的，于是乎，

> 问题1：就出现了内存碎片问题。
>
> 问题2：一直在因为小块内存而进行内存申请，调用malloc，系统调用产生性能问题。

策略：如果申请的内存大小超过128，那么空间配置器就自动调用一级空间配置器。反之调用二级空间配置器。

**一级空间配置器，STL源码中的一级空间配置器命名为class __malloc_alloc_template ，它很简单，就是对malloc，free，realloc等系统分配函数的一层封装。**

**二级空间配置器，由一个内存池和自由链表配合实现的。**

#  算法概述

算法主要是由头文件<algorithm><functional><numeric>组成。

<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等...

<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.

<functional> 定义了一些模板类,用以声明函数对象。

## 常用遍历算法

```
/*
    遍历算法 遍历容器元素
	@param beg 开始迭代器
	@param end 结束迭代器
	@param _callback  函数回调或者函数对象
	@return 函数对象
*/
for_each(iterator beg, iterator end, _callback);
/*
	transform算法 将指定容器区间元素搬运到另一容器中
	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存
	@param beg1 源容器开始迭代器
	@param end1 源容器结束迭代器
	@param beg2 目标容器开始迭代器
	@param _cakkback 回调函数或者函数对象
	@return 返回目标容器迭代器
*/
transform(iterator beg1, iterator end1, iterator beg2, _callbakc)

```

for_each:

```c++
/*

template<class _InIt,class _Fn1> inline
void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
{
	for (; _First != _Last; ++_First)
		_Func(*_First);
}

*/

//普通函数
void print01(int val){
	cout << val <<" ";
}
//函数对象
struct print001{
	voidoperator()(int val){
		cout << val <<" ";
	}
};

//for_each算法基本用法
void test01(){
	
	vector<int> v;
	for(int i =0; i <10;i++){
		v.push_back(i);
	}

	//遍历算法
	for_each(v.begin(), v.end(), print01);
	cout << endl;

	for_each(v.begin(), v.end(), print001());
	cout << endl;

}

struct print02{
	print02(){
		mCount =0;
	}
	voidoperator()(int val){
		cout << val <<" ";
		mCount++;
	}
	int mCount;
};

//for_each返回值
void test02(){

	vector<int> v;
	for(int i =0; i <10; i++){
		v.push_back(i);
	}

	print02& p = for_each(v.begin(), v.end(), print02());
	cout << endl;
	cout << p.mCount << endl;
}

struct print03 :public binary_function<int,int,void>{
	voidoperator()(int val,int bindParam)const{
		cout << val + bindParam <<" ";
	}
};

//for_each绑定参数输出
void test03(){
	
	vector<int> v;
	for(int i =0; i <10; i++){
		v.push_back(i);
	}

	for_each(v.begin(), v.end(), bind2nd(print03(),100));
}
```

transform:

```c++
//transform 将一个容器中的值搬运到另一个容器中
/*
	template<class _InIt, class _OutIt, class _Fn1> inline 
	_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)
	{	

		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Func(*_First);
		return (_Dest);
	}

	template<class _InIt1,class _InIt2,class _OutIt,class _Fn2> inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
		for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
			*_Dest = _Func(*_First1, *_First2);
		return (_Dest);
	}
*/

struct transformTest01{
	intoperator()(int val){
		return val +100;
	}
};
struct print01{
	voidoperator()(int val){
		cout << val <<" ";
	}
};
void test01(){

	vector<int> vSource;
	for(int i =0; i <10;i ++){
		vSource.push_back(i +1);
	}

	//目标容器
	vector<int> vTarget;
	//给vTarget开辟空间
	vTarget.resize(vSource.size());
	//将vSource中的元素搬运到vTarget
	vector<int>::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());
	//打印
	for_each(vTarget.begin(), vTarget.end(), print01()); cout << endl;
	
}

//将容器1和容器2中的元素相加放入到第三个容器中
struct transformTest02{
	intoperator()(int v1,int v2){
		return v1 + v2;
	}
};
void test02(){

	vector<int> vSource1;
	vector<int> vSource2;
	for(int i =0; i <10; i++){
		vSource1.push_back(i +1);	
	}

	//目标容器
	vector<int> vTarget;
	//给vTarget开辟空间
	vTarget.resize(vSource1.size());
	transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());
	//打印
	for_each(vTarget.begin(), vTarget.end(), print01()); cout << endl;
}
```



## 常用查找算法

```
/*
	find算法 查找元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return 返回查找元素的位置
*/
find(iterator beg, iterator end, value)
/*
	adjacent_find算法 查找相邻重复元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)
	@return 返回相邻元素的第一个位置的迭代器
*/
adjacent_find(iterator beg, iterator end, _callback);
/*
	binary_search算法 二分查找法
	注意: 在无序序列中不可用
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return bool 查找返回true 否则false
*/
bool binary_search(iterator beg, iterator end, value);
/*
	find_if算法 条件查找
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return bool 查找返回true 否则false
*/
find_if(iterator beg, iterator end, _callback);
/*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  value回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count(iterator beg, iterator end, value);
/*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count_if(iterator beg, iterator end, _callback);
```



## 常用排序算法

```
/*
	merge算法 容器元素合并，并存储到另一容器中
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
*/
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	sort算法 容器元素排序
	注意:两个容器必须是有序的
	@param beg 容器1开始迭代器
	@param end 容器1结束迭代器
	@param _callback 回调函数或者谓词(返回bool类型的函数对象)
*/
sort(iterator beg, iterator end, _callback)
/*
	random_shuffle算法 对指定范围内的元素随机调整次序
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
random_shuffle(iterator beg, iterator end)
/*
	reverse算法 反转指定范围的元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
reverse(iterator beg, iterator end)
```



## 常用拷贝和替换算法

```c++
/*
	copy算法 将容器内指定范围的元素拷贝到另一容器中
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param dest 目标容器结束迭代器
*/
copy(iterator beg, iterator end, iterator dest)
/*
	replace算法 将容器内指定范围的旧元素修改为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param oldvalue 旧元素
	@param oldvalue 新元素
*/
replace(iterator beg, iterator end, oldvalue, newvalue)
/*
	replace_if算法 将容器内指定范围满足条件的元素替换为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param callback函数回调或者谓词(返回Bool类型的函数对象)
	@param oldvalue 新元素
*/
replace_if(iterator beg, iterator end, _callback, newvalue)
/*
	swap算法 互换两个容器的元素
	@param c1容器1
	@param c2容器2
*/
swap(container c1, container c2)
```



## 常用算数生成算法

```c++
/*
	accumulate算法 计算容器元素累计总和
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value累加值
*/
accumulate(iterator beg, iterator end, value)
/*
	fill算法 向容器中添加元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value t填充元素
*/
fill(iterator beg, iterator end, value)
```



##  常用集合算法

```c++
/*
	set_intersection算法 求两个set集合的交集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_union算法 求两个set集合的并集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_difference算法 求两个set集合的差集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
```



#  **STL综合案例(学校演讲比赛)**

***\*学校演讲比赛介绍\****

1）某市举行一场演讲比赛（ speech_contest ），共有24个人参加。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。

2）比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛；

第一轮分为4个小组，每组6个人。比如100-105为一组，106-111为第二组，依次类推，

每人分别按照抽签（draw）顺序演讲。当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。

​	第二轮分为2个小组，每组6人。比赛完毕，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。

​	第三轮只剩下6个人，本轮为决赛，选出前三名。

4）比赛评分：10个评委打分，去除最低、最高分，求平均分

每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。

选手的名次按得分降序排列，若得分一样，按参赛号升序排名。

 

用STL编程，求解这个问题

1） 请打印出所有选手的名字与参赛号，并以参赛号的升序排列。

2） 打印每一轮比赛后，小组比赛成绩和小组晋级名单

3） 打印决赛前三名，选手名称、成绩。

 

***\*需求分析\****

//产生选手（ABCDEFGHIJKLMNOPQRSTUVWXYZ）姓名、得分；选手编号

//第1轮	选手抽签选手比赛查看比赛结果

//第2轮	选手抽签选手比赛查看比赛结果

//第3轮	选手抽签选手比赛查看比赛结果

 